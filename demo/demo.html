<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<!--
 * Copyright (c) 2020 Eric Bruneton
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
-->
    <title>Black Hole Shader Demo</title>
    <link rel="stylesheet"
          type="text/css"
          href=
"https://framework.web.cern.ch/framework/2.0/fonts/PTSansWeb/PTSansWeb.css"/>
    <style>

html, body {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 0;
  margin: 0;
  background-color: #888;
  color: #FFF;
  font-family: 'PT Sans', sans-serif;
  font-size: 14px;
  text-shadow: 1px 1px 2px black;
  user-select: none;
  overflow: hidden;
}

.cv-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.cv-error-panel {
  position: absolute;
  top: 33%;
  width: 30%;
  display: flex;
  margin: 0 calc(35% - 16px);
  padding: 16px;
  align-items: center;
  background-color: #A00;
  border: 1px solid #FFF;
  box-shadow: 1px 1px 2px #000;
  text-align: center;
  text-shadow: none;
  z-index: 2;
}

.cv-warning {
  background-color: #FB3;
  color: #000;
}

.cv-loading-panel {
  position: absolute;
  bottom: 16%;
  width: 100%;
  display: flex;
  align-items: center;
  flex-direction: column;
  z-index: 1;
}

.cv-loading-bar {
  position: relative;
  width: 50%;
  height: 16px;
  margin: 16px 0;
  border: 1px solid #FFF;
  box-shadow: 1px 1px 2px #000;
  opacity: 0.5;
}

.cv-loading-bar-value {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 33%;
  background-color: #F00;
}

.cv-loaded {
  display: none;
}

.cv-copyright {
  position: absolute;
  bottom: 4px;
  right: 8px;
  color: #FFF;
}

.cv-copyright a {
  color: #FFF;
  font-style: italic;
  text-decoration: none;
}

.cv-hidden {
  display: none;
}

.op-panel {
  position: absolute;
  top: 0;
  right: 0;
  overflow: hidden;
}

.op-hidden {
  display: none;
}

.op-dot {
  position: absolute;
  width: 8px;
  height: 8px;
  background-color: #F00;
  border-radius: 50%;
  transform: translate(-4px, -4px);
}

.op-frustum {
  position: absolute;
  left: 0;
  top: 0;
  width: 1px;
  height: 1px;
  background-color: #F00;
  transform-origin: left center;
}

.op-info {
  position: absolute;
  left: 0;
  top: 0;
  padding: 8px;
}


.sp-panel {
  position: absolute;
  left: 0;
  top: 0;
  padding: 0 8px;
}

.sp-panel h3 {
  margin: 8px 0;
  font-size: 1.1em;
}

.sp-panel summary {
  margin: 8px 0;
  font-size: 1.2em;
  font-weight: bold;
}

.sp-settings-container {
  padding-left: 8px;
}

.sp-setting {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
}

.sp-setting label {
  margin-right: 8px;
}

.sp-slider-container {
  display: flex;
  height: 12px;
  margin-left: auto;
  align-items: center;
}

.sp-slider-container button {
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 0;
  padding: 0;
  margin: 0;
  background: transparent;
  color: #FFF;
  cursor: pointer;
  font-size: 12px;
  line-height: 12px;
  text-align: center;
  text-shadow: 1px 1px 2px black;
  user-select: none;
}

.sp-slider-container button[disabled] {
  cursor: initial;
  opacity: 0.2;
}

.sp-slider-container input[type="range"] {
  width: 128px;
  height: 12px;
  margin: 0;
  padding: 0;
  -webkit-appearance: none;
  appearance: none;
  background: #000;
  box-shadow: 1px 1px 2px #000;
  cursor: pointer;
  outline: none;
  opacity: 0.5;
  overflow: hidden;
}

.sp-slider-container input[type="range"]::-webkit-slider-thumb {
  width: 0px;
  height: 12px;
  -webkit-appearance: none;
  appearance: none;
  background: #00F;
  box-shadow: -100vw 0 0 100vw #00F;
}

.sp-slider-container input[type="range"]::-moz-range-thumb {
  width: 0px;
  height: 12px;
  background: #00F;
  box-shadow: -100vw 0 0 100vw #00F;
  box-sizing: border-box;     
}

.sp-slider-container input[type="range"][disabled] {
  cursor: initial;
  opacity: 0.2;
}

.sp-value {
  width: 48px;
  margin-left: 8px;
  font-size: 0.8em;
  overflow: hidden;
  text-overflow: ellipsis;
}

.sp-setting input[type="checkbox"] {
  width: 16px;
  margin: 0 180px 0 0;
  padding: 0;
}

.sp-setting.sp-last {
  margin-bottom: 16px;
}

.sp-target-container {
  width: 200px;
  margin: 4px 0;        
  line-height: 0;
}

.sp-target-container button {
  width: 24px;
  padding: 0;
  margin: 0;
  background: transparent;
  border: 0;
  color: #FFF;
  cursor: pointer;
  font-size: 24px;
  text-align: center;
  text-shadow: 1px 1px 2px black;
  user-select: none;
}

.sp-target-container[select="0"] #sp_target0,
.sp-target-container[select="1"] #sp_target1,
.sp-target-container[select="2"] #sp_target2,
.sp-target-container[select="3"] #sp_target3,
.sp-target-container[select="4"] #sp_target4 {
  color: #00F;
}

.sp-panel:not(.sp-playing) #sp_target1,
.sp-panel:not(.sp-playing) #sp_target2,
.sp-panel:not(.sp-playing) #sp_target3,
.sp-panel:not(.sp-playing) #sp_target4 {
  display: none;
}

.sp-play-container {
  width: 192px;
  margin: 4px 0;        
  line-height: 0;
}

.sp-play,
.sp-pause,
.sp-stop {
  width: 24px;
  padding: 0;
  margin: 0 8px 0 0;
  background: transparent;
  border: 0;
  color: #FFF;
  cursor: pointer;
  font-size: 24px;
  text-align: center;
  text-shadow: 1px 1px 2px black;
  user-select: none;
}

.sp-panel.sp-playing .sp-play,
.sp-panel:not(.sp-playing) .sp-pause,
.sp-panel:not(.sp-playing) .sp-stop {
  display: none;
}

.sp-hidden {
  display: none;
}

    </style>
    <script>

BlackHoleShaderDemoApp = {};
(function() {

// The speed of light.
const C = 299792458;

// The gravitational constant.
const G = 6.6743e-11;

// The mass of the Sun.
const SOLAR_MASS = 1.98847e30;

class BooleanValue {
  constructor(model, defaultValue) {
    this.model = model;
    this.value = defaultValue;
    this.defaultValue = defaultValue;
  }
  getDefaultValue() { return this.defaultValue; }
  getValue() { return this.value; }
  setValue(value) {
    this.value = !!value;
    this.model.notifyListeners();
  }
}

class QuantizedValue {
  constructor(model, f, defaultIndex, size = 1000) {
    this.model = model;
    this.values = Array.from({length: size + 1}, (value, i) => f(i / size));
    this.index = defaultIndex;
    this.defaultIndex = defaultIndex;
  }
  getSize() { return this.values.length; }
  getDefaultIndex() { return this.defaultIndex; }
  getIndex() { return this.index; }
  getValue() { return this.values[this.index]; }
  setIndex(index) { 
    this.index = Math.max(0, Math.min(index, this.values.length - 1)); 
    this.model.notifyListeners();
  }
  setValue(value) {
    let i0 = 0;
    let i1 = this.values.length - 1;
    if (value <= this.values[i0]) {
      this.index = i0;
    } else if (value >= this.values[i1]) {
      this.index = i1;
    } else {
      while (i1 > i0 + 1) {
        const i = Math.floor((i0 + i1) / 2);
        if (value < this.values[i]) {
          i1 = i;
        } else {
          i0 = i;
        }
      }
      this.index = value - this.values[i0] < this.values[i1] - value ? i0 : i1;
    }
    this.model.notifyListeners();
  }
}

const State = {
  STOPPED: 'STOPPED',
  PLAYING: 'PLAYING',
  PAUSED: 'PAUSED'
};

const Target = {
  DEFAULT: 0,
  BLACK_HOLE: 1,
  LEFT: 2,
  FORWARD: 3,
  RIGHT: 4
};

const safeSqrt = function(x) {
  return Math.sqrt(Math.max(x, 0));
};

const matrixProduct = function(a, b) {
  const c = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      for (let k = 0; k < 4; ++k) {
        c[i][j] += a[i][k] * b[k][j];
      }
    }
  }
  return c;
};

const vectorMatrixProduct = function(v, m) {
  const c = [0, 0, 0, 0];
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      c[i] += v[j] * m[j][i];
    }
  }
  return c;
};

class Model {
  constructor() {
    this.cameraTarget = 
        new QuantizedValue(this, (x) => 4 * x, 0, 4);
    this.cameraYaw = 
        new QuantizedValue(this, (x) => 2 * Math.PI * x, 0, 36000);
    this.cameraPitch =
        new QuantizedValue(this, (x) => Math.PI * (x - 0.5), 9000, 18000);
    this.exposure = 
        new QuantizedValue(this, (x) => Math.pow(10, 3 * x - 3), 500);
    this.bloom = 
        new QuantizedValue(this, (x) => x, 500);
    this.highDefinition =
        new BooleanValue(this, false);
    this.highContrast =
        new BooleanValue(this, false);
    this.startRadius = 
        new QuantizedValue(this, (x) => Math.max(1 + 39 * x * x, 1.01), 940);
    this.startDirection = 
        new QuantizedValue(this, (x) => Math.PI * (x - 0.5), 1800, 1800);
    this.startSpeed = 
        new QuantizedValue(this, (x) => Math.min(x * x, 0.99), 347);
    this.orbitInclination = 
        new QuantizedValue(this, (x) => Math.PI * (x - 0.5), 970, 1799);
    this.lensing =
        new BooleanValue(this, true);
    this.doppler =
        new BooleanValue(this, true);
    this.grid =
        new BooleanValue(this, false);
    this.blackHoleMass = 
        new QuantizedValue(this, (x) => 10 * Math.pow(10, 6 * x), 384);
    this.discDensity = 
        new QuantizedValue(this, (x) => 100 * Math.pow(x, 10), 500);
    this.discOpacity =
        new QuantizedValue(this, (x) => x, 300);
    this.discTemperature = 
        new QuantizedValue(this, (x) => 1000 * Math.pow(10, x), 430);
    this.rocketDistance =
        new QuantizedValue(this, (x) => 30 + 50 * x, 500);
    this.rocket =
        new BooleanValue(this, false);
    this.starsYaw = 
        new QuantizedValue(this, (x) => 2 * Math.PI * (x - 0.5), 1800, 3600);
    this.starsPitch = 
        new QuantizedValue(this, (x) => Math.PI * (x - 0.5), 900, 1800);
    this.starsRoll = 
        new QuantizedValue(this, (x) => 2 * Math.PI * (x - 0.5), 1800, 3600);
    this.stars =
        new BooleanValue(this, true);
    this.starsMatrix = undefined;

    // The current state of the camera (i.e. the observer) motion.
    this.state = State.STOPPED;
    // The constant of motion dt / dTau = e / (1 - u) of the camera.
    this.e = undefined;
    // The constant of motion dphi / dTau = l u^2 of the camera.
    this.l = undefined;
    // The current value of the Schwarzschild's t coordinate of the camera.
    this.t = 0;
    // The current value of the Schwarzschild's r coordinate of the camera.
    this.r = undefined;
    // The current value of the derivative of r with respect to proper time.
    this.drOverDtau = undefined;
    // The current value of the Schwarzschild's theta coordinate of the camera.
    this.worldTheta = undefined;
    // The current value of the Schwarzschild's phi coordinate of the camera.
    this.worldPhi = undefined;
    // The current value of the Schwarzschild's phi coordinate of the camera (in
    // rotated coordinates such that its orbit is in the equatorial plane).
    this.phi = undefined;
    // The Lorentz transformation matrix specifying the current camera 
    // orientation and velocity.
    this.lorentz = undefined;
    // The camera position, in (pseudo-)Cartesian coordinates.
    this.p = undefined;
    // The camera 4-velocity, in Schwarzschild coordinates.
    this.kS = undefined;
    // The camera's vertical field of view.
    this.fovY = 50 / 180 * Math.PI;
    // The yaw offset added to the user controlled camera yaw.
    this.cameraYawOffset = 0;
    // The base vectors of the camera reference frame, in (pseudo-)Cartesian
    // coordinates.
    this.eTau = undefined;
    this.eW = undefined;
    this.eH = undefined;
    this.eD = undefined;

    // The orientation of the rocket (tangent to the orbit).
    this.rocketYaw = 0;
    // The Lorentz transformation matrix specifying the current rocket
    // orientation and velocity.
    this.rocketLorentz = undefined;
    // The base vectors of the rocket reference frame, in (pseudo-)Cartesian
    // coordinates.
    this.rocketTau = undefined;
    this.rocketW = undefined;
    this.rocketH = undefined;
    this.rocketD = undefined;

    this.blackHoleRadiusMeters = undefined;
    this.speedMetersPerSecond = undefined;
    this.gForce = undefined;
    this.localElapsedTimeSeconds = 0;
    this.globalElapsedTimeSeconds = 0;

    this.updateDerivedValues();
    this.listeners = [];
  }

  addListener(listener) {
    this.listeners.push(listener);
  }

  setState(state) {
    if (state != this.state) {
      this.state = state;
      if (state == State.PLAYING) {
        this.t = 0;
        this.localElapsedTimeSeconds = 0;
        this.globalElapsedTimeSeconds = 0;
      }
      this.notifyListeners(false);
    }
  }

  updateOrbit(dTauSeconds) {
    const M = this.blackHoleMass.getValue() * SOLAR_MASS;
    const dTauOverDtauSeconds = C * C * C / ( 2 * G * M);
    const dTau = dTauOverDtauSeconds * dTauSeconds;

    let u = 1 / this.r;
    const e = this.e;
    const l = this.l;
    const dtOverDtau = 
        this.state == State.PLAYING ? e / (1 - u) : 1 / Math.sqrt(1 - u);
    this.t += dtOverDtau * dTau;
    this.localElapsedTimeSeconds += dTauSeconds;
    this.globalElapsedTimeSeconds += dtOverDtau * dTauSeconds;

    if (this.state == State.PLAYING) {
      const n = 1000;
      const dTauN = dTau / n;
      for (let i = 0; i < n; ++i) {
        u = 1 / this.r;
        const d2rOverDtau2 = u * u * (l * l * (2 - 3 * u) * u - 1) / 2;
        this.drOverDtau += d2rOverDtau2 * dTauN;
        this.r += this.drOverDtau * dTauN;
        this.phi += l * u * u * dTauN;
        if (this.r <= 1.0 || this.r > 100.0) {
          this.setState(State.STOPPED);
          return;
        }
      }
    }
    this.notifyListeners(false);
  }

  notifyListeners(settingsChanged = true) {
    this.updateDerivedValues();
    for (let listener of this.listeners) {
      if (settingsChanged) {
        listener.onSettingsChange();
      }
      listener.onOrbitChange();
    }
  }

  updateDerivedValues() {
    this.updateStarsMatrix();
    this.updateCameraCoordinates();
    this.updateCameraAndRocketLorentzTransforms();
    this.updateCameraAndRocketReferenceFrames();
    this.updateOrbitInfo();
  }

  updateStarsMatrix() {
    const cy = Math.cos(this.starsYaw.getValue() + Math.PI);
    const sy = Math.sin(this.starsYaw.getValue() + Math.PI);
    const cp = Math.cos(this.starsPitch.getValue());
    const sp = Math.sin(this.starsPitch.getValue());
    const cr = Math.cos(this.starsRoll.getValue());
    const sr = Math.sin(this.starsRoll.getValue());
    this.starsMatrix = [
                     cp * cy,                cp * sy,     -sp,
      sr * sp * cy - cr * sy, sr * sp * sy + cr * cy, sr * cp,
      cr * sp * cy + sr * sy, cr * sp * sy - sr * cy, cr * cp
    ];
  }

  updateCameraCoordinates() {
    const r0 = this.startRadius.getValue();
    const delta = this.startDirection.getValue();
    const v = this.startSpeed.getValue();

    // Compute the constants of motion from the initial conditions r0, delta, v.
    const u0 = 1 / r0;
    const cotDelta = 1 / Math.tan(delta);
    const e2 = (1 - u0) / (1 - v * v);
    const l2 = (e2 - 1 + u0) / (u0 * u0 * (1 - u0 + cotDelta * cotDelta));
    const e = safeSqrt(e2);
    const l = delta == 0 ? 0 : (delta > 0 ? 1 : -1) * safeSqrt(l2);
    this.e = e;
    this.l = l;

    // Update the Schwarzschild coordinates of the camera.
    if (this.state == State.STOPPED) {
      this.r = r0;
      this.drOverDtau = -safeSqrt(e2 - (1 - u0) - l * l * u0 * u0 * (1 - u0));
      this.phi = 0;
    }
    const ci = Math.cos(this.orbitInclination.getValue());
    const si = Math.sin(this.orbitInclination.getValue());
    const cphi = Math.cos(this.phi);
    const sphi = Math.sin(this.phi);
    this.worldTheta = Math.acos(cphi * si);
    this.worldPhi = Math.atan2(sphi, cphi * ci);
  }

  updateCameraAndRocketLorentzTransforms() {
    // Compute the 4-velocity vector of the camera (in rotated Schwarzschild
    // coordinates such that its orbit is in the equatorial plane).
    const e = this.e;
    const l = this.l;
    const u = 1 / this.r;
    let k;
    if (this.state == State.PLAYING) {
      k = [e / (1 - u), this.drOverDtau, 0, l * u * u];
    } else {
      k = [1 / Math.sqrt(1 - u), 0, 0, 0];
    }

    // Compute the rotation matrix from the global Schwarzschild reference frame
    // e_t, e_r, e_theta, e_phi to the rotated Schwarzschild reference frame
    // such that the camera orbit is in the equatorial plane.
    const ct = Math.cos(this.worldTheta);
    const st = Math.sin(this.worldTheta);
    const cp = Math.cos(this.worldPhi);
    const sp = Math.sin(this.worldPhi);
    const ci = Math.cos(this.orbitInclination.getValue());
    const si = Math.sin(this.orbitInclination.getValue());
    const ca = si * ct * cp + st * ci;
    const sa = si * sp;
    const orbitRot = [
      [1, 0,  0,   0],
      [0, 1,  0,   0],
      [0, 0, ca, -sa],
      [0, 0, sa,  ca]];

    // Compute the 4-velocity of the camera in the *rotated* reference frame of 
    // a STATIC observer at this location.
    const k_s = 
        [k[0] * Math.sqrt(1 - u), k[1] / Math.sqrt(1 - u), k[2] / u, k[3] / u];
    // Compute the speed vector of the camera in the *rotated* reference frame
    // of a STATIC observer at this location.
    const v = [k_s[1] / k_s[0], k_s[2] / k_s[0], k_s[3] / k_s[0]];
    // Compute the corresponding Lorentz factor gamma and the corresponding
    // Lorentz boost matrix (for a rotated static observer).
    const v2 = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    const gamma = 1 / Math.sqrt(1 - v2);
    const gv = v2 == 0 ? 0 : (gamma - 1) / v2;
    const boost = [
        [     gamma,       gamma*v[0],       gamma*v[1],       gamma*v[2]],
        [gamma*v[0], 1 + gv*v[0]*v[0],     gv*v[0]*v[1],     gv*v[0]*v[2]],
        [gamma*v[1],     gv*v[1]*v[0], 1 + gv*v[1]*v[1],     gv*v[1]*v[2]],
        [gamma*v[2],     gv*v[2]*v[0],     gv*v[2]*v[1], 1 + gv*v[2]*v[2]]];

    // Compute the direction the camera should be looking at.
    this.cameraYawOffset = 0;
    if (this.state == State.PLAYING) {
      if (this.cameraTarget.getValue() == Target.BLACK_HOLE) {
        this.cameraYawOffset = this.getYaw(boost, -1, 0) - Math.PI;
      } else if (this.cameraTarget.getValue() != Target.DEFAULT) {
        this.cameraYawOffset = this.getYaw(boost, k_s[1], k_s[3]) - Math.PI +
            (Target.FORWARD - this.cameraTarget.getValue()) * Math.PI / 2;
      }
    }
    // Compute the rotation matrix of the camera, in its local reference frame.
    const cosY = Math.cos(this.cameraYaw.getValue() + this.cameraYawOffset);
    const sinY = Math.sin(this.cameraYaw.getValue() + this.cameraYawOffset);
    const cosP = Math.cos(this.cameraPitch.getValue());
    const sinP = Math.sin(this.cameraPitch.getValue());
    const cameraRot = [
        [1,            0,     0,            0],
        [0,        -sinY,     0,         cosY],
        [0, -cosY * sinP, -cosP, -sinY * sinP],
        [0,  cosY * cosP, -sinP,  sinY * cosP]];

    // The final Lorentz transform is the product of the 3 above matrices.
    this.lorentz = matrixProduct(cameraRot, matrixProduct(boost, orbitRot));

    // Compute the direction of the rocket.
    if (this.state == State.PLAYING) {
      this.rocketYaw = this.getYaw(boost, k_s[1], k_s[3]);
    } else {
      this.rocketYaw = 0;
    }
    // Compute the rotation matrix of the rocket.
    const cosRy = Math.cos(this.rocketYaw);
    const sinRy = Math.sin(this.rocketYaw);
    const rocketRot = [
        [1,      0,  0,     0],
        [0, -sinRy,  0, cosRy],
        [0,      0, -1,     0],
        [0,  cosRy,  0, sinRy]];
    // The final Lorentz transform is the product of the 3 above matrices.
    this.rocketLorentz = 
        matrixProduct(rocketRot, matrixProduct(boost, orbitRot));
  }

  getYaw(boost, dr, dphi) {
    const dt = -Math.sqrt(dr * dr + dphi * dphi);
    const dr0 = -boost[1][0] * dt + boost[1][1] * dr + boost[1][3] * dphi;
    const dphi0 = -boost[3][0] * dt + boost[3][1] * dr + boost[3][3] * dphi;
    return Math.atan2(dphi0, dr0);
  }

  updateCameraAndRocketReferenceFrames() {
    const r = this.r;
    const cos_theta = Math.cos(this.worldTheta);
    const sin_theta = Math.sin(this.worldTheta);
    const cos_phi = Math.cos(this.worldPhi);
    const sin_phi = Math.sin(this.worldPhi);

    const u = 1 / r;
    const v = Math.sqrt(1 - u);
    const ur = [sin_theta * cos_phi, sin_theta * sin_phi, cos_theta];

    const e_t = [1 / v, 0, 0, 0];
    const e_r = [0, v * ur[0], v * ur[1], v * ur[2]];
    const e_theta = [0, cos_theta * cos_phi, cos_theta * sin_phi, -sin_theta];
    const e_phi = [0, -sin_phi, cos_phi, 0];

    const L = this.lorentz;
    const e_static = [e_t, e_r, e_theta, e_phi];
    this.eTau = vectorMatrixProduct(L[0], e_static);
    this.eW = vectorMatrixProduct(L[1], e_static);
    this.eH = vectorMatrixProduct(L[2], e_static);
    this.eD = vectorMatrixProduct(L[3], e_static);

    this.rocketTau = vectorMatrixProduct(this.rocketLorentz[0], e_static);
    this.rocketW = vectorMatrixProduct(this.rocketLorentz[1], e_static);
    this.rocketH = vectorMatrixProduct(this.rocketLorentz[2], e_static);
    this.rocketD = vectorMatrixProduct(this.rocketLorentz[3], e_static);

    this.p = [r * ur[0], r * ur[1], r * ur[2]];
    this.kS = [L[0][0] / v, v * L[0][1], u * L[0][2], u / sin_theta * L[0][3]];
  }

  updateOrbitInfo() {
    const M = this.blackHoleMass.getValue() * SOLAR_MASS;
    this.blackHoleRadiusMeters = 2 * G  * M / (C * C);
    const e = this.e;
    const u = 1 / this.r;
    if (this.state == State.PLAYING) {
      this.speedMetersPerSecond = Math.sqrt(1 - (1 - u) / (e * e)) * C;
      this.gForce = 0;
      this.timeDilationFactor = e / (1 - u);
    } else {
      const rMeters = this.r * this.blackHoleRadiusMeters;
      this.speedMetersPerSecond = 0;
      this.gForce = G * M / (rMeters * rMeters * Math.sqrt(1 - u));
      this.timeDilationFactor = 1 / Math.sqrt(1 - u);
    }
  }
}

BlackHoleShaderDemoApp.State = State;
BlackHoleShaderDemoApp.model = new Model();
})();

(function(model, State){

class BoolParam {
  constructor(name, model) {
    this.name = name;
    this.model = model;
  }
  read(searchParams) {
    const value = searchParams.get(this.name);
    if (this.model.getDefaultValue()) {
      this.model.setValue(value != '0');
    } else {
      this.model.setValue(value == '1');
    }
  }
  write(searchParams) {
    if (this.model.getValue() == this.model.getDefaultValue()) {
      searchParams.delete(this.name);
    } else {
      searchParams.set(this.name, this.model.getValue() ? '1' : '0');
    }
  }
}

class IntParam {
  constructor(name, model) {
    this.name = name;
    this.model = model;
  }
  read(searchParams) {
    const index = parseInt(searchParams.get(this.name));
    if (index >= 0) {
      this.model.setIndex(index);
    }
  }
  write(searchParams) {
    if (this.model.getIndex() == this.model.getDefaultIndex()) {
      searchParams.delete(this.name);
    } else {
      searchParams.set(this.name, this.model.getIndex());
    }
  }
}

class UrlParams {
  constructor(model) {
    this.model = model;

    this.params = [];
    this.params.push(new IntParam('ct', model.cameraTarget));
    this.params.push(new IntParam('cy', model.cameraYaw));
    this.params.push(new IntParam('cp', model.cameraPitch));
    this.params.push(new IntParam('ce', model.exposure));
    this.params.push(new IntParam('cb', model.bloom));
    this.params.push(new BoolParam('hd', model.highDefinition));
    this.params.push(new BoolParam('hc', model.highContrast));
    this.params.push(new IntParam('or', model.startRadius));
    this.params.push(new IntParam('od', model.startDirection));
    this.params.push(new IntParam('os', model.startSpeed));
    this.params.push(new IntParam('oi', model.orbitInclination));
    this.params.push(new BoolParam('pl', model.lensing));
    this.params.push(new BoolParam('pd', model.doppler));
    this.params.push(new BoolParam('sg', model.grid));
    this.params.push(new IntParam('bhm', model.blackHoleMass));
    this.params.push(new IntParam('dd', model.discDensity));
    this.params.push(new IntParam('do', model.discOpacity));
    this.params.push(new IntParam('dt', model.discTemperature));
    this.params.push(new IntParam('srd', model.rocketDistance));
    this.params.push(new BoolParam('sr', model.rocket));
    this.params.push(new IntParam('sfy', model.starsYaw));
    this.params.push(new IntParam('sfp', model.starsPitch));
    this.params.push(new IntParam('sfr', model.starsRoll));
    this.params.push(new BoolParam('sfe', model.stars));
    this.lastState = undefined;

    this.timeout = null;
    this.readUrlParams();
    this.model.addListener(this);
  }

  onSettingsChange() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.timeout = setTimeout(() => this.writeUrlParams(), 500);
  }

  onOrbitChange() {
    if (this.model.state == this.lastState) {
      return;
    }
    this.lastState = this.model.state;
    if (this.model.state != State.PLAYED) {
      this.writeUrlParams();
    }
  }

  readUrlParams() {
    const searchParams = new URLSearchParams(window.location.search);
    for (let param of this.params) {
      param.read(searchParams);
    }
    const r = parseFloat(searchParams.get('r'));
    const dr = parseFloat(searchParams.get('dr'));
    const phi = parseFloat(searchParams.get('phi'));
    if (!isNaN(r) && !isNaN(dr) && !isNaN(phi) && r > 1) {
      this.model.r = r;
      this.model.drOverDtau = dr;
      this.model.phi = phi;
      this.model.state = State.PAUSED;
    }
  }

  writeUrlParams() {
    const url = new URL(window.location.toString());
    const searchParams = new URLSearchParams(url.search);
    for (let param of this.params) {
      param.write(searchParams);
    }
    if (model.state == State.PAUSED) {
      searchParams.set('r', this.model.r);
      searchParams.set('dr', this.model.drOverDtau);
      searchParams.set('phi', this.model.phi);
    } else {
      searchParams.delete('r');
      searchParams.delete('dr');
      searchParams.delete('phi');
    }
    url.search = searchParams.toString();
    window.history.replaceState(null, null, url.toString());
    this.timeout = null;
  }
}

window.addEventListener('DOMContentLoaded', () => new UrlParams(model));
})(BlackHoleShaderDemoApp.model, BlackHoleShaderDemoApp.State);
(function() {
const BLOOM_FILTERS = [
  600,
  [[0.537425,0.0200664,0.00720805,0.0015972,0.000907317,0.000275642],
   [0.102792,0.0185013,0.00291111,0.000519003,0.000519003,0.000519003],
   [0.0704669,0.0181097,0.00232751,0.00232751,0.0015737,0.0015737],
   [0.0117432,0.0117432,0.00226476,0.00154524,0.00116041,0.00116041],
   [0.00746695,0.00746695,0.00171226,0.00104832,0.000766638,0.000766638],
   [0.00478257,0.00478257,0.00100513,0.000818812,0.000397319,0.000397319],
   [0.0037712,0.0037712,0.000490891,0.000490891,0.000490891,0.000490891],
   [0.00108603,0.00108603,0.000924505,0.000924505,0.000141374,0],
   [0.000604275,0.000604275,0.000604275,0.000604275,0.000604275,0.000604275]],
  800,
  [[0.368483,0.0216534,0.00816304,0.00188928,0.00108659,0.000313496],
   [0.136249,0.0234538,0.0044714,0.000355959,0.000355959,0.000355959],
   [0.115467,0.0273797,0.00361202,0.00361202,0.0024381,0.0024381],
   [0.0185586,0.0185586,0.00364918,0.00244913,0.00186549,0.00186549],
   [0.0120676,0.0120676,0.00279833,0.00169769,0.00125113,0.00125113],
   [0.00782081,0.00782081,0.00165563,0.00133947,0.000653398,0.000653398],
   [0.00620986,0.00620986,0.0008107,0.0008107,0.0008107,0.0008107],
   [0.0017856,0.0017856,0.00153169,0.00153169,0.000231589,0],
   [0.000999842,0.000999842,0.000999842,0.000999842,0.000999842,0.000999842]],
  1000,
  [[0.256172,0.0203539,0.00797156,0.00192098,0.00111651,0.000302983],
   [0.153181,0.0252457,0.0056879,5.24735e-05,5.24735e-05,5.24735e-05],
   [0.154089,0.0348566,0.00470551,0.00470551,0.00317819,0.00317819],
   [0.0246407,0.0246407,0.00494194,0.00326092,0.00251954,0.00251954],
   [0.0163845,0.0163845,0.00384115,0.00230972,0.00171516,0.00171516],
   [0.010743,0.010743,0.00229079,0.00184054,0.000902617,0.000902617],
   [0.00858938,0.00858938,0.00112463,0.00112463,0.00112463,0.00112463],
   [0.00246603,0.00246603,0.0021316,0.0021316,0.000318642,0],
   [0.00138965,0.00138965,0.00138965,0.00138965,0.00138965,0.00138965]],
  1200,
  [[0.183275,0.0181576,0.00737853,0.00184847,0.00110057,0.000302963],
   [0.155444,0.026573,0.00631122,0,0,0],
   [0.175386,0.0406837,0.00558637,0.00558637,0.00379343,0.00379343],
   [0.0298822,0.0298822,0.00611926,0.00396558,0.00310871,0.00310871],
   [0.0203221,0.0203221,0.00481554,0.00287054,0.00214781,0.00214781],
   [0.0134794,0.0134794,0.00289524,0.00230992,0.00113896,0.00113896],
   [0.0108519,0.0108519,0.00142504,0.00142504,0.00142504,0.00142504],
   [0.00311065,0.00311065,0.0027096,0.0027096,0.000400401,0],
   [0.00176416,0.00176416,0.00176416,0.00176416,0.00176416,0.00176416]],
  1400,
  [[0.13507,0.015829,0.00665187,0.00173139,0.00105678,0.000303016],
   [0.150222,0.0270593,0.006541,0,0,0],
   [0.188342,0.0450054,0.00639373,0.0062499,0.00430739,0.00430739],
   [0.034393,0.034393,0.00718937,0.00457886,0.00363942,0.00363942],
   [0.0239205,0.0239205,0.00572745,0.00338534,0.00255212,0.00255212],
   [0.016048,0.016048,0.00347179,0.00275076,0.00136368,0.00136368],
   [0.013009,0.013009,0.00171332,0.00171332,0.00171332,0.00171332],
   [0.00372296,0.00372296,0.00326808,0.00326808,0.000477361,0],
   [0.00212503,0.00212503,0.00212503,0.00212503,0.00212503,0.00212503]],
  1600,
  [[0.102246,0.013671,0.00592138,0.00159768,0.00100127,0.000299667],
   [0.14157,0.026801,0.0065711,0,0,0],
   [0.19617,0.0482116,0.00708177,0.0067665,0.00473425,0.00473425],
   [0.0382986,0.0382986,0.00816852,0.00511466,0.00412131,0.00412131],
   [0.0272343,0.0272343,0.00658764,0.00386174,0.00293299,0.00293299],
   [0.0184784,0.0184784,0.00402643,0.00316811,0.00157908,0.00157908],
   [0.0150825,0.0150825,0.00199223,0.00199223,0.00199223,0.00199223],
   [0.00430923,0.00430923,0.00381212,0.00381212,0.000550361,0],
   [0.00247558,0.00247558,0.00247558,0.00247558,0.00247558,0.00247558]],
];

// Provides a bloom shader effect by mipmapping an input image, filtering each
// mipmap with a small kernel, and upsampling and adding the filtered images.

const MAX_LEVELS = 9;
const MAX_FLOAT16 = '6.55e4';

const VERTEX_SHADER =
  `#version 300 es
  layout(location=0) in vec4 vertex;
  void main() { gl_Position = vertex; }`;

const DOWNSAMPLE_SHADER =
  `#version 300 es
  precision highp float;
  const vec4 WEIGHTS = vec4(1.0, 3.0, 3.0, 1.0) / 8.0;
  uniform sampler2D source;
  uniform vec2 source_delta_uv;
  layout(location=0) out vec4 frag_color;
  void main() { 
    vec2 ij = floor(gl_FragCoord.xy);
    vec2 source_ij = ij * 2.0 - vec2(1.5);
    vec2 source_uv = source_ij * source_delta_uv;
    vec3 color = vec3(0.0);
    for (int i = 0; i < 4; ++i) {
      float wi = WEIGHTS[i];
      for (int j = 0; j < 4; ++j) {
        float wj = WEIGHTS[j];
        vec2 delta_uv = vec2(i, j) * source_delta_uv;
        color += wi * wj * texture(source, source_uv + delta_uv).rgb;
      }
    }
    frag_color = vec4(min(color, ${MAX_FLOAT16}), 1.0);
  }`;

const BLOOM_SHADER =
  `#version 300 es
  precision highp float;
  uniform sampler2D source;
  uniform vec2 source_delta_uv;
  uniform vec3 source_samples_uvw[SIZE];
  layout(location=0) out vec4 frag_color;
  void main() { 
    vec2 source_uv = (gl_FragCoord.xy + vec2(1.0)) * source_delta_uv;
    vec3 color = vec3(0.0);
    for (int i = 0; i < SIZE; ++i) {
      vec3 uvw = source_samples_uvw[i];
      color += uvw.z * texture(source, source_uv + uvw.xy).rgb;
    }
    frag_color = vec4(min(color, ${MAX_FLOAT16}), 1.0);
  }`;

const UPSAMPLE_SHADER =
  `#version 300 es
  precision highp float;
  const vec4 WEIGHTS[4] = vec4[4] (
    vec4(1.0, 3.0, 3.0, 9.0) / 16.0,
    vec4(3.0, 1.0, 9.0, 3.0) / 16.0,
    vec4(3.0, 9.0, 1.0, 3.0) / 16.0,
    vec4(9.0, 3.0, 3.0, 1.0) / 16.0
  );
  uniform sampler2D source;
  uniform vec2 source_delta_uv;
  layout(location=0) out vec4 frag_color;
  void main() {
    vec2 ij = floor(gl_FragCoord.xy);
    vec2 source_ij = floor((ij - vec2(1.0)) * 0.5) + vec2(0.5);
    vec2 source_uv = source_ij * source_delta_uv;
    vec3 c0 = texture(source, source_uv).rgb;
    vec3 c1 = texture(source, source_uv + vec2(source_delta_uv.x, 0.0)).rgb;
    vec3 c2 = texture(source, source_uv + vec2(0.0, source_delta_uv.y)).rgb;
    vec3 c3 = texture(source, source_uv + source_delta_uv).rgb;
    vec4 weight = WEIGHTS[int(mod(ij.x, 2.0) + 2.0 * mod(ij.y, 2.0))];
    vec3 color = weight.x * c0 + weight.y * c1 + weight.z * c2 + weight.w * c3;
    frag_color = vec4(min(color, ${MAX_FLOAT16}), 1.0);
  }`;

const RENDER_SHADER =
  `#version 300 es
  precision highp float;
  uniform sampler2D source;
  uniform vec2 source_delta_uv;
  uniform vec3 source_samples_uvw[SIZE];
  uniform sampler2D bloom;
  uniform vec2 bloom_delta_uv;
  uniform float intensity;
  uniform float exposure;
  uniform bool high_contrast;
  layout(location=0) out vec4 frag_color;

  vec3 toneMap(vec3 color) {
    return pow(vec3(1.0) - exp(-color), vec3(1.0 / 2.2));
  }
  
  // ACES tone map, see
  // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
  vec3 toneMapACES(vec3 color) {
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    color = (color * (A * color + B)) / (color * (C * color + D) + E);
    return pow(color, vec3(1.0 / 2.2));
  }

  void main() {
    vec2 source_uv = (gl_FragCoord.xy + vec2(1.0)) * source_delta_uv;
    vec3 color = texture(bloom, 0.5 * gl_FragCoord.xy * bloom_delta_uv).rgb;
    for (int i = 0; i < SIZE; ++i) {
      vec3 uvw = source_samples_uvw[i];
      color += uvw.z * texture(source, source_uv + uvw.xy).rgb;
    }
    color = mix(texture(source, source_uv).rgb, color, intensity) * exposure;
    color = min(color, 10.0);
    if (high_contrast) {
      color = toneMapACES(color);
    } else {
      color = toneMap(color);
    }
    frag_color = vec4(color, 1.0);
  }`;

const createShader = function(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
};

const createTexture = function(gl, textureUnit, target) {
  const texture = gl.createTexture();
  gl.activeTexture(textureUnit);
  gl.bindTexture(target, texture);
  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return texture;
};

// Usage: create an instance for the desired viewport size, and draw your scene
// between a call to begin() and a call to end(). Use resize() when the viewport
// size changes.
class Bloom {

  constructor(gl, width, height) {
    this.gl = gl;
    this.width = width;
    this.height = height;
    gl.getExtension('OES_texture_float_linear');
    gl.getExtension('EXT_color_buffer_float');
    gl.getExtension('EXT_float_blend');

    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,
       new Float32Array([-1, -1, +1, -1, -1, +1, +1, +1]), gl.STATIC_DRAW);

    const vertexShader = 
        createShader(gl, gl.VERTEX_SHADER, VERTEX_SHADER);

    this.downsampleProgram = gl.createProgram();
    gl.attachShader(this.downsampleProgram, vertexShader);
    gl.attachShader(this.downsampleProgram, 
        createShader(gl, gl.FRAGMENT_SHADER, DOWNSAMPLE_SHADER));
    gl.linkProgram(this.downsampleProgram);
    gl.useProgram(this.downsampleProgram);
    gl.uniform1i(gl.getUniformLocation(this.downsampleProgram, 'source'), 0);
    this.downsampleProgram.sourceDeltaUvUniform = 
        gl.getUniformLocation(this.downsampleProgram, 'source_delta_uv');

    this.bloomProgram = gl.createProgram();
    gl.attachShader(this.bloomProgram, vertexShader);
    gl.attachShader(this.bloomProgram, 
        createShader(gl, gl.FRAGMENT_SHADER, 
            BLOOM_SHADER.replace(/SIZE/g, 25)));
    gl.linkProgram(this.bloomProgram);
    gl.useProgram(this.bloomProgram);
    gl.uniform1i(gl.getUniformLocation(this.bloomProgram, 'source'), 0);
    this.bloomProgram.sourceDeltaUvUniform = 
        gl.getUniformLocation(this.bloomProgram, 'source_delta_uv');

    this.upsampleProgram = gl.createProgram();
    gl.attachShader(this.upsampleProgram, vertexShader);
    gl.attachShader(this.upsampleProgram, 
        createShader(gl, gl.FRAGMENT_SHADER, UPSAMPLE_SHADER));
    gl.linkProgram(this.upsampleProgram);
    gl.useProgram(this.upsampleProgram);
    gl.uniform1i(gl.getUniformLocation(this.upsampleProgram, 'source'), 0);
    this.upsampleProgram.sourceDeltaUvUniform = 
        gl.getUniformLocation(this.upsampleProgram, 'source_delta_uv');

    this.renderProgram = gl.createProgram();
    gl.attachShader(this.renderProgram, vertexShader);
    gl.attachShader(this.renderProgram, 
        createShader(gl, gl.FRAGMENT_SHADER, 
            RENDER_SHADER.replace(/SIZE/g, 25)));
    gl.linkProgram(this.renderProgram);
    gl.useProgram(this.renderProgram);
    gl.uniform1i(gl.getUniformLocation(this.renderProgram, 'source'), 0);
    gl.uniform1i(gl.getUniformLocation(this.renderProgram, 'bloom'), 1);
    this.renderProgram.intensityUniform = 
        gl.getUniformLocation(this.renderProgram, 'intensity');
    this.renderProgram.exposureUniform = 
        gl.getUniformLocation(this.renderProgram, 'exposure');
    this.renderProgram.highContrastUniform = 
        gl.getUniformLocation(this.renderProgram, 'high_contrast');
    this.renderProgram.sourceDeltaUvUniform = 
        gl.getUniformLocation(this.renderProgram, 'source_delta_uv');
    this.renderProgram.bloomDeltaUvUniform = 
        gl.getUniformLocation(this.renderProgram, 'bloom_delta_uv'); 

    this.numLevels = 0;
    this.mipmapTextures = [];
    this.filterTextures = [];
    this.bloomFilters = [];
    for (let i = 0; i < MAX_LEVELS; ++i) {
      const mipmapTexture = createTexture(gl, gl.TEXTURE0, gl.TEXTURE_2D);
      this.mipmapTextures.push(mipmapTexture);
      if (i > 0) {
        const filterTexture = createTexture(gl, gl.TEXTURE0, gl.TEXTURE_2D);
        if (i == 1) {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }
        this.filterTextures.push(filterTexture);
      } else {
        this.filterTextures.push(null);
      }
    }

    this.mipmapFbos = [];
    this.filterFbos = [];
    this.depthBuffer = undefined;
    for (let i = 0; i < MAX_LEVELS; ++i) {
      const mipmapFbo = gl.createFramebuffer();
      this.mipmapFbos.push(mipmapFbo);
      gl.bindFramebuffer(gl.FRAMEBUFFER, mipmapFbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
          gl.TEXTURE_2D, this.mipmapTextures[i], 0);
      if (i > 0) {
        const filterFbo = gl.createFramebuffer();
        this.filterFbos.push(filterFbo);
        gl.bindFramebuffer(gl.FRAMEBUFFER, filterFbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
            gl.TEXTURE_2D, this.filterTextures[i], 0);
      } else {
        this.depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
            this.mipmapTextures[0].width, this.mipmapTextures[0].height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
            gl.RENDERBUFFER, this.depthBuffer);
        this.filterFbos.push(null);
      }
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this.resize(width, height);
  }

  resize(width, height) {
    this.width = width;
    this.height = height;

    const gl = this.gl;
    gl.activeTexture(gl.TEXTURE0);
    let level = 0;
    let w = width;
    let h = height;
    while (h > 2 && level < MAX_LEVELS) {
      gl.bindTexture(gl.TEXTURE_2D, this.mipmapTextures[level]);
      gl.texImage2D(
          gl.TEXTURE_2D, 0, gl.RGBA16F, w + 2, h + 2, 0, gl.RGBA, gl.FLOAT, 
          null);
      this.mipmapTextures[level].width = w + 2;
      this.mipmapTextures[level].height = h + 2;
      if (level > 0) {
        gl.bindTexture(gl.TEXTURE_2D, this.filterTextures[level]);
        gl.texImage2D(
           gl.TEXTURE_2D, 0, gl.RGBA16F, w, h, 0, gl.RGBA, gl.FLOAT, null);
        this.filterTextures[level].width = w;
        this.filterTextures[level].height = h;
      } else {
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
            this.mipmapTextures[0].width, this.mipmapTextures[0].height);
      }
      level += 1;
      w = Math.ceil(w / 2);
      h = Math.ceil(h / 2);
    }
    this.numLevels = level;

    let nearest_size_index = 0;
    let nearest_size = BLOOM_FILTERS[nearest_size_index];
    for (let i = 2; i < BLOOM_FILTERS.length; i += 2) {
      const size = BLOOM_FILTERS[i]
      if (Math.abs(BLOOM_FILTERS[i] - height) < 
          Math.abs(nearest_size - height)) {
        nearest_size_index = i;
        nearest_size = BLOOM_FILTERS[i];
      }
    }

    const filters = BLOOM_FILTERS[nearest_size_index + 1];
    for (let i = 0; i < this.numLevels; ++i) {
      const bloomFilter = [];
      const width = this.mipmapTextures[i].width;
      const height = this.mipmapTextures[i].height;
      for (let y = -2; y <= 2; ++y) {
        const iy = Math.abs(y);
        for (let x = -2; x <= 2; ++x) {
          const ix = Math.abs(x);
          const index = 
              ix < iy ? (iy * (iy + 1)) / 2 + ix : (ix * (ix + 1)) / 2 + iy;
          const w = filters[i][index];
          bloomFilter.push([x / width, y / height, w]);
        }
      }
      this.bloomFilters.push(bloomFilter);
    }
  }

  begin() {
    const gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.mipmapFbos[0]);
    gl.viewport(1, 1, this.mipmapTextures[0].width - 2, 
        this.mipmapTextures[0].height - 2);
  }

  end(intensity, exposure, highContrast) {
    const gl = this.gl;
    gl.activeTexture(gl.TEXTURE0);

    let program = this.downsampleProgram;
    gl.useProgram(program);
    for (let level = 1; level < this.numLevels; ++level) {
      const targetTexture = this.mipmapTextures[level];
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.mipmapFbos[level]);
      gl.viewport(1, 1, targetTexture.width - 2, targetTexture.height - 2);
      gl.bindTexture(gl.TEXTURE_2D, this.mipmapTextures[level - 1]);
      gl.uniform2f(program.sourceDeltaUvUniform, 
          1.0 / this.mipmapTextures[level - 1].width,
          1.0 / this.mipmapTextures[level - 1].height);
      this.drawQuad(program);
    }

    program = this.bloomProgram;
    gl.useProgram(program);
    for (let level = 1; level < this.numLevels; ++level) {
      const targetTexture = this.filterTextures[level];
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.filterFbos[level]);
      gl.viewport(0, 0, targetTexture.width, targetTexture.height);
      gl.bindTexture(gl.TEXTURE_2D, this.mipmapTextures[level]);
      gl.uniform2f(program.sourceDeltaUvUniform, 
          1.0 / this.mipmapTextures[level].width,
          1.0 / this.mipmapTextures[level].height);
      for (let i = 0; i < 25; ++i) {
        gl.uniform3f(gl.getUniformLocation(program, `source_samples_uvw[${i}]`),
            this.bloomFilters[level][i][0],
            this.bloomFilters[level][i][1], 
            this.bloomFilters[level][i][2]);
      }
      this.drawQuad(program);
    }

    program = this.upsampleProgram;
    gl.activeTexture(gl.TEXTURE0);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE);
    gl.useProgram(program);
    for (let level = this.numLevels - 2; level >= 1; --level) {
      const targetTexture = this.filterTextures[level];
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.filterFbos[level]);
      gl.viewport(0, 0, targetTexture.width, targetTexture.height);
      gl.bindTexture(gl.TEXTURE_2D, this.filterTextures[level + 1]);
      gl.uniform2f(program.sourceDeltaUvUniform, 
          1.0 / this.filterTextures[level + 1].width,
          1.0 / this.filterTextures[level + 1].height);
      this.drawQuad(program);
    }
    gl.disable(gl.BLEND);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.width, this.height);

    program = this.renderProgram;
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.mipmapTextures[0]);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.filterTextures[1]);
    gl.uniform2f(program.sourceDeltaUvUniform, 
        1.0 / this.mipmapTextures[0].width, 
        1.0 / this.mipmapTextures[0].height);
    gl.uniform2f(program.bloomDeltaUvUniform, 
        1.0 / this.filterTextures[1].width,
        1.0 / this.filterTextures[1].height);
    if (this.numLevels > 0) {
      for (let i = 0; i < 25; ++i) {
        gl.uniform3f(gl.getUniformLocation(program, `source_samples_uvw[${i}]`),
            this.bloomFilters[0][i][0],
            this.bloomFilters[0][i][1], 
            this.bloomFilters[0][i][2]);
      }
    }
    gl.uniform1f(program.intensityUniform, intensity);
    gl.uniform1f(program.exposureUniform, exposure);
    gl.uniform1i(program.highContrastUniform, highContrast ? 1 : 0);
    this.drawQuad(program);
  }

  drawQuad(program) {
    const gl = this.gl;
    const vertexAttrib = gl.getAttribLocation(program, 'vertex');
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(
        vertexAttrib,
        /*numComponents=*/ 2,
        /*type=*/ this.gl.FLOAT,
        /*normalize=*/ false,
        /*stride=*/ 0,
        /*offset=*/ 0);
    gl.enableVertexAttribArray(vertexAttrib);
    gl.drawArrays(gl.TRIANGLE_STRIP, /*offset=*/ 0, /*vertexCount=*/ 4);
  }
}
BlackHoleShaderDemoApp.Bloom = Bloom;
})();

(function() {

const NEAR_PLANE = 0.1;
const FAR_PLANE = 100;

const ENV_MAP_LEVELS = 7;
const ENV_MAP_SIZE = 1 << (ENV_MAP_LEVELS - 1);

const EXHAUST_RADIUS = 0.514;
const EXHAUST_Z_MIN = -20;
const EXHAUST_Z_MAX = -2.1;

const createShader = function(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
};

const loadRocketMesh = function(rocketDataUrl, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', rocketDataUrl);
  xhr.responseType = 'arraybuffer';
  xhr.onload = (event) => {
    const data = new DataView(xhr.response);
    const numVertexFloats = data.getUint32(0, true);
    const numIndices = data.getUint32(Uint32Array.BYTES_PER_ELEMENT, true);

    let offset = 2 * Uint32Array.BYTES_PER_ELEMENT;
    const vertices = new Float32Array(numVertexFloats);
    for (let i = 0; i < numVertexFloats; ++i) {
      vertices[i] =
          data.getFloat32(i * Float32Array.BYTES_PER_ELEMENT + offset, true);
    }
 
    offset += numVertexFloats * Float32Array.BYTES_PER_ELEMENT;
    const indices = new Uint32Array(numIndices);
    for (let i = 0; i < numIndices; ++i) {
      indices[i] =
          data.getUint32(i * Uint32Array.BYTES_PER_ELEMENT + offset, true);
    }
    callback(vertices, indices);
  };
  xhr.send();
};

const loadRocketTexture = function(gl, textureUrl) {
  const glExt = gl.getExtension('EXT_texture_filter_anisotropic');
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                   gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameterf(gl.TEXTURE_2D, glExt.TEXTURE_MAX_ANISOTROPY_EXT, 
                   gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
  const image = new Image();
  image.addEventListener('load', function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
  });
  image.src = textureUrl;
  return texture;
}

class RocketManager {
  constructor(model, gl) {
    this.model = model;
    this.gl = gl;
    this.rocketProgram = undefined;
    this.exhaustProgram = undefined;
    this.envMapTexture = undefined;
    this.envMapFbo = undefined;
    this.rocketVertexBuffer = undefined;
    this.rocketIndexBuffer = undefined;
    this.exhaustVertexBuffer = undefined;
    this.exhaustIndexBuffer = undefined;
    this.baseColorTexture = loadRocketTexture(gl, 'rocket_base_color.png');
    this.occlusionRoughnessMetallicTexture =
        loadRocketTexture(gl, 'rocket_occlusion_roughness_metallic.png');
    this.normalMapTexture = loadRocketTexture(gl, 'rocket_normal.png');

    this.createRocketProgram(gl);
    this.createExhaustProgram(gl);
    this.createEnvMap(gl);
    loadRocketMesh('rocket.dat', 
        (vertices, indices) => this.createRocketBuffers(vertices, indices));
    this.createExhaustBuffers(gl);
  }

  createEnvMap(gl) {
    this.envMapTexture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.envMapTexture);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.envMapTexture);
    gl.texStorage2D(gl.TEXTURE_CUBE_MAP, ENV_MAP_LEVELS, gl.RGBA16F,
        ENV_MAP_SIZE, ENV_MAP_SIZE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER,
                     gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    const glExt = gl.getExtension('EXT_texture_filter_anisotropic');
    gl.texParameterf(gl.TEXTURE_CUBE_MAP, glExt.TEXTURE_MAX_ANISOTROPY_EXT, 
                     gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));

    this.envMapFbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.envMapFbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_POSITIVE_X, this.envMapTexture, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  createRocketProgram(gl) {
    const vertexShader = createShader(
        gl, 
        gl.VERTEX_SHADER,
        `#version 300 es
        precision highp float;
        ${document.querySelector("#rocket_vertex_shader").innerHTML}`);
    const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        `#version 300 es
        precision highp float;
        const float ENV_MAP_SIZE = float(${ENV_MAP_SIZE});
        ${document.querySelector("#rocket_fragment_shader").innerHTML}`);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);    

    program.positionAttrib =
        gl.getAttribLocation(program, 'position_attribute');
    program.normalAttrib =
        gl.getAttribLocation(program, 'normal_attribute');
    program.tangentAttrib =
        gl.getAttribLocation(program, 'tangent_attribute');
    program.uvAttrib =
        gl.getAttribLocation(program, 'uv_attribute');
    program.ambientOcclusionAttrib =
        gl.getAttribLocation(program, 'ambient_occlusion_attribute');
    program.modelViewProjMatrix =
        gl.getUniformLocation(program, 'model_view_proj_matrix');
    program.camera = 
        gl.getUniformLocation(program, 'camera');
    program.baseColorTexture =
        gl.getUniformLocation(program, 'base_color_texture');
    program.occlusionRoughnessMetallicTexture =
        gl.getUniformLocation(program, 'occlusion_roughness_metallic_texture');
    program.normalMapTexture =
        gl.getUniformLocation(program, 'normal_map_texture');
    program.envMapTexture =
        gl.getUniformLocation(program, 'env_map_texture');
    this.rocketProgram = program;
  }

  createExhaustProgram(gl) {
    const vertexShader = createShader(
        gl, 
        gl.VERTEX_SHADER,
        `#version 300 es
        precision highp float;
        ${document.querySelector("#exhaust_vertex_shader").innerHTML}`);
    const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        `#version 300 es
        precision highp float;
        const float RADIUS = float(${EXHAUST_RADIUS});
        const float Z_MIN = float(${EXHAUST_Z_MIN});
        const float Z_MAX = float(${EXHAUST_Z_MAX});
        ${document.querySelector("#exhaust_fragment_shader").innerHTML}`);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);    

    program.positionAttrib =
        gl.getAttribLocation(program, 'position_attribute');
    program.modelViewProjMatrix =
        gl.getUniformLocation(program, 'model_view_proj_matrix');
    program.camera = gl.getUniformLocation(program, 'camera');
    program.intensity = gl.getUniformLocation(program, 'intensity');
    program.kZ = gl.getUniformLocation(program, 'k_z');
    program.kR = gl.getUniformLocation(program, 'k_r');
    this.exhaustProgram = program;
  }

  createRocketBuffers(vertices, indices) {
    const gl = this.gl;

    this.rocketVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.rocketVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    this.rocketIndexBuffer = gl.createBuffer();
    this.rocketIndexBuffer.size = indices.length;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.rocketIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);    
  }

  createExhaustBuffers(gl) {
    const NUM_CIRCUMFERENCE_SAMPLES = 32;

    const vertices = new Float32Array(6 * (NUM_CIRCUMFERENCE_SAMPLES + 1));
    for (let i = 0; i <= NUM_CIRCUMFERENCE_SAMPLES; ++i) {
      const r = i == 0 ? 0 : EXHAUST_RADIUS;
      const alpha = (2 * Math.PI * i) / NUM_CIRCUMFERENCE_SAMPLES;
      vertices[6 * i] = r * Math.cos(alpha); 
      vertices[6 * i + 1] = r * Math.sin(alpha); 
      vertices[6 * i + 2] = EXHAUST_Z_MIN;
      vertices[6 * i + 3] = r * Math.cos(alpha); 
      vertices[6 * i + 4] = r * Math.sin(alpha); 
      vertices[6 * i + 5] = EXHAUST_Z_MAX;     
    }

    this.exhaustVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.exhaustVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const indices = new Uint32Array(12 * NUM_CIRCUMFERENCE_SAMPLES);
    for (let i = 1; i <= NUM_CIRCUMFERENCE_SAMPLES; ++i) {
      const j = (i % NUM_CIRCUMFERENCE_SAMPLES) + 1;
      indices[12 * i - 12] = 0;
      indices[12 * i - 11] = 2 * j;
      indices[12 * i - 10] = 2 * i;
      indices[12 * i - 9] = 2 * i;
      indices[12 * i - 8] = 2 * j;
      indices[12 * i - 7] = 2 * j + 1;
      indices[12 * i - 6] = 2 * j + 1;
      indices[12 * i - 5] = 2 * i + 1;
      indices[12 * i - 4] = 2 * i;
      indices[12 * i - 3] = 1;
      indices[12 * i - 2] = 2 * i + 1;
      indices[12 * i - 1] = 2 * j + 1;
    }    
    this.exhaustIndexBuffer = gl.createBuffer();
    this.exhaustIndexBuffer.size = indices.length;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.exhaustIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);    
  }

  renderEnvMap(program, quadVertexBuffer) {
    const gl = this.gl;
    const model = this.model;

    const currentViewport = gl.getParameter(gl.VIEWPORT);
    const currentFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.envMapFbo);
    gl.viewport(0, 0, ENV_MAP_SIZE, ENV_MAP_SIZE);

    gl.useProgram(program);
    gl.uniform3f(program.cameraSize, 
        ENV_MAP_SIZE / 2, ENV_MAP_SIZE / 2, ENV_MAP_SIZE / 2);
    gl.uniform3f(program.eTau,
        model.rocketTau[1], model.rocketTau[2], model.rocketTau[3]);

    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);
    gl.vertexAttribPointer(program.vertexAttrib, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(program.vertexAttrib);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_POSITIVE_X, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        -model.rocketD[1], -model.rocketD[2], -model.rocketD[3]);
    gl.uniform3f(program.eH,
        -model.rocketH[1], -model.rocketH[2], -model.rocketH[3]);
    gl.uniform3f(program.eD,
        -model.rocketW[1], -model.rocketW[2], -model.rocketW[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_NEGATIVE_X, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        model.rocketD[1], model.rocketD[2], model.rocketD[3]);
    gl.uniform3f(program.eH,
        -model.rocketH[1], -model.rocketH[2], -model.rocketH[3]);
    gl.uniform3f(program.eD,
        model.rocketW[1], model.rocketW[2], model.rocketW[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        model.rocketW[1], model.rocketW[2], model.rocketW[3]);
    gl.uniform3f(program.eH,
        model.rocketD[1], model.rocketD[2], model.rocketD[3]);
    gl.uniform3f(program.eD,
        -model.rocketH[1], -model.rocketH[2], -model.rocketH[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        model.rocketW[1], model.rocketW[2], model.rocketW[3]);
    gl.uniform3f(program.eH,
        -model.rocketD[1], -model.rocketD[2], -model.rocketD[3]);
    gl.uniform3f(program.eD,
        model.rocketH[1], model.rocketH[2], model.rocketH[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        model.rocketW[1], model.rocketW[2], model.rocketW[3]);
    gl.uniform3f(program.eH,
        -model.rocketH[1], -model.rocketH[2], -model.rocketH[3]);
    gl.uniform3f(program.eD,
        -model.rocketD[1], -model.rocketD[2], -model.rocketD[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,   
        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, this.envMapTexture, 0);
    gl.uniform3f(program.eW,
        -model.rocketW[1], -model.rocketW[2], -model.rocketW[3]);
    gl.uniform3f(program.eH,
        -model.rocketH[1], -model.rocketH[2], -model.rocketH[3]);
    gl.uniform3f(program.eD,
        model.rocketD[1], model.rocketD[2], model.rocketD[3]);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.disableVertexAttribArray(program.vertexAttrib);
    gl.bindFramebuffer(gl.FRAMEBUFFER, currentFbo);
    gl.viewport(currentViewport[0], currentViewport[1], currentViewport[2],
        currentViewport[3]);
  }

  drawRocket() {
    if (!this.rocketVertexBuffer) return;

    const gl = this.gl;
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.baseColorTexture);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.occlusionRoughnessMetallicTexture);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, this.normalMapTexture);
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.envMapTexture);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

    const program = this.rocketProgram;
    gl.useProgram(program);
    gl.uniform1i(program.baseColorTexture, 0);
    gl.uniform1i(program.occlusionRoughnessMetallicTexture, 1);
    gl.uniform1i(program.normalMapTexture, 2);
    gl.uniform1i(program.envMapTexture, 3);
    this.setCameraUniforms(program);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.rocketVertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.rocketIndexBuffer);
    const stride = (3 + 3 + 4 + 1 + 2) * 4;
    gl.vertexAttribPointer(
        program.positionAttrib, 3, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(
        program.normalAttrib, 3, gl.FLOAT, false, stride, 3 * 4);
    gl.vertexAttribPointer(
        program.tangentAttrib, 4, gl.FLOAT, false, stride, 6 * 4);
    gl.vertexAttribPointer(
        program.uvAttrib, 2, gl.FLOAT, false, stride, 10 * 4);
    gl.vertexAttribPointer(
        program.ambientOcclusionAttrib, 1, gl.FLOAT, false, stride, 12 * 4);
    gl.enableVertexAttribArray(program.positionAttrib);
    gl.enableVertexAttribArray(program.normalAttrib);
    gl.enableVertexAttribArray(program.tangentAttrib);
    gl.enableVertexAttribArray(program.uvAttrib);
    gl.enableVertexAttribArray(program.ambientOcclusionAttrib);

    gl.drawElements(
        gl.TRIANGLES, this.rocketIndexBuffer.size, gl.UNSIGNED_INT, 0);

    gl.disableVertexAttribArray(program.positionAttrib);
    gl.disableVertexAttribArray(program.normalAttrib);
    gl.disableVertexAttribArray(program.tangentAttrib);
    gl.disableVertexAttribArray(program.uvAttrib);
    gl.disableVertexAttribArray(program.ambientOcclusionAttrib);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
  }

  drawExhaust(time, gForce) {
    if (!this.rocketVertexBuffer) return;

    const gl = this.gl;
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE);
    gl.enable(gl.CULL_FACE);

    const program = this.exhaustProgram;
    gl.useProgram(program);

    const intensity = 0.1 * Math.pow(gForce, 0.75);
    gl.uniform3f(program.intensity, 
        46 / 255 * intensity, 176 / 255 * intensity, intensity);

    time *= 100;
    const kR1 = 6.75 + 0.5 * Math.cos(time);
    const kR2 = 5.75 + 0.5 * Math.cos((time + 1) / Math.sqrt(2));
    const kR3 = 4.75 + 0.5 * Math.cos((time + 2) / Math.sqrt(3));
    const R2 = EXHAUST_RADIUS * EXHAUST_RADIUS;
    gl.uniform3f(program.kR, kR1 / R2, kR2 / R2, kR3 / R2);

    const kZ1 = 27 + 2 * Math.cos((time + 1) / Math.sqrt(2));
    const kZ2 = 23 + 2 * Math.cos((time + 2) / Math.sqrt(3));
    const kZ3 = 19 + 2 * Math.cos(time);
    const DZ = EXHAUST_Z_MAX - EXHAUST_Z_MIN;
    gl.uniform3f(program.kZ, kZ1 / DZ, kZ2 / DZ, kZ3 / DZ);
    this.setCameraUniforms(program);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.exhaustVertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.exhaustIndexBuffer);
    gl.vertexAttribPointer(
        program.positionAttrib, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(program.positionAttrib);

    gl.cullFace(gl.BACK);
    gl.drawElements(
        gl.TRIANGLES, this.exhaustIndexBuffer.size, gl.UNSIGNED_INT, 0);

    gl.cullFace(gl.FRONT);
    gl.drawElements(
        gl.TRIANGLES, this.exhaustIndexBuffer.size, gl.UNSIGNED_INT, 0);

    gl.disableVertexAttribArray(program.positionAttrib);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
  }

  setCameraUniforms(program) {
    const yaw = this.model.cameraYaw.getValue() + this.model.cameraYawOffset -
        this.model.rocketYaw;
    const cameraDist = this.model.rocketDistance.getValue() / 2;
    const offsetDist = 0.4 * cameraDist;
    const tx = -offsetDist * Math.sin(this.model.rocketYaw);
    const tz = offsetDist * Math.cos(this.model.rocketYaw);
    const cy = Math.cos(yaw);
    const sy = Math.sin(yaw);
    const cp = Math.cos(this.model.cameraPitch.getValue());
    const sp = Math.sin(this.model.cameraPitch.getValue());
    const modelViewMatrix = [
      [      cy,  0,      -sy,                    cy * tx      - sy * tz],
      [-sy * sp, cp, -cy * sp,             - sy * sp * tx - cy * sp * tz],
      [ sy * cp, sp,  cy * cp, -cameraDist + sy * cp * tx + cy * cp * tz],
      [       0,  0,        0,                                         1]
    ];

    const f = 1 / Math.tan(this.model.fovY / 2);
    const a = document.body.clientWidth / document.body.clientHeight;
    const b = -(FAR_PLANE + NEAR_PLANE) / (FAR_PLANE - NEAR_PLANE);
    const c = -2 * FAR_PLANE * NEAR_PLANE / (FAR_PLANE - NEAR_PLANE);
    const projMatrix = [
      [f / a, 0,  0, 0],
      [    0, f,  0, 0],
      [    0, 0,  b, c],
      [    0, 0, -1, 0]
    ];

    const modelViewProjMatrix = 
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let i = 0; i < 4; ++i) {
      for (let j = 0; j < 4; ++j) {
        for (let k = 0; k < 4; ++k) {
          modelViewProjMatrix[i + 4 * j] +=
              projMatrix[i][k] * modelViewMatrix[k][j];
        }
      }
    }
    this.gl.uniformMatrix4fv(program.modelViewProjMatrix, false,
        modelViewProjMatrix);

    const camera = [0, 0, 0, 1];
    for (let i = 0; i < 3; ++i) {
      for (let j = 0; j < 3; ++j) {
        camera[i] -= modelViewMatrix[j][i] * modelViewMatrix[j][3];
      }
    }
    this.gl.uniform3f(program.camera, camera[0], camera[1], camera[2]);
  }
}

BlackHoleShaderDemoApp.RocketManager = RocketManager;
})();

(function() {

// Max LOD for which the manul texture filtering method DefaultStarColor() in
// model.glsl must be used for stars. Above this level a default anisotropic
// texture filtering is used instead. Must be consistent with the same constant
// in shader_manager.js.
const MAX_STAR_TEXTURE_LOD = 6;

const cubeMapTargets = function(gl) {
  return [
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
};

const createTexture = function(gl, target) {
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, texture);
  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return texture;
};

const loadTextureData = function(textureDataUrl, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', textureDataUrl);
  xhr.responseType = 'arraybuffer';
  xhr.onload = (event) => {
    const data = new DataView(xhr.response);
    const array =
        new Float32Array(data.byteLength / Float32Array.BYTES_PER_ELEMENT);
    for (let i = 0; i < array.length; ++i) {
      array[i] = data.getFloat32(i * Float32Array.BYTES_PER_ELEMENT, true);
    }
    callback(array);
  };
  xhr.send();
};

const loadIntTextureData = function(textureDataUrl, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', textureDataUrl);
  xhr.responseType = 'arraybuffer';
  xhr.onload = (event) => {
    const data = new DataView(xhr.response);
    const array =
        new Uint32Array(data.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    for (let i = 0; i < array.length; ++i) {
      array[i] = data.getUint32(i * Uint32Array.BYTES_PER_ELEMENT, true);
    }
    callback(array);
  };
  xhr.send();
};

const loadNoiseTexture = function(gl, glExt, textureUrl) {
  const texture = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,
                   gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameterf(gl.TEXTURE_2D, glExt.TEXTURE_MAX_ANISOTROPY_EXT, 
                   gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
  const image = new Image();
  image.addEventListener('load', function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, gl.RED, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
  });
  image.src = textureUrl;
  return texture;
}


class TextureManager {
  constructor(rootElement, gl) {
    this.loadingPanel = rootElement.querySelector('#cv_loading_panel');
    this.loadingBar = rootElement.querySelector('#cv_loading_bar');
    this.gl = gl;

    this.rayDeflectionTexture = null;
    this.rayInverseRadiusTexture = null;
    this.blackbodyTexture = null;
    this.dopplerTexture = null;
    this.gridTexture = null;

    this.galaxyTexture = null;
    this.starTexture = null;
    this.starTexture2 = null;
    this.tilesQueue = [];
    this.numTilesLoaded = 0;
    this.numTilesLoadedPerLevel = [0, 0, 0, 0, 0];
    this.numPendingRequests = 0;

    const ext = gl.getExtension('EXT_texture_filter_anisotropic');
    this.loadTextures(ext);
    this.loadStarTextures(ext);
    this.noiseTexture = loadNoiseTexture(gl, ext, 'noise_texture.png');

    document.body.addEventListener('keypress', (e) => this.onKeyPress(e)); 
  }

  loadTextures(ext) {
    const gl = this.gl;

    loadTextureData('deflection.dat', (data) => {
      this.rayDeflectionTexture = createTexture(gl, gl.TEXTURE_2D);
      this.rayDeflectionTexture.width = data[0];
      this.rayDeflectionTexture.height = data[1];
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, data[0], data[1], 0, 
                    gl.RG, gl.FLOAT, data.slice(2));
    });

    loadTextureData('inverse_radius.dat', (data) => {
      this.rayInverseRadiusTexture = createTexture(gl, gl.TEXTURE_2D);
      this.rayInverseRadiusTexture.width = data[0];
      this.rayInverseRadiusTexture.height = data[1];
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RG32F, data[0], data[1], 0,
                    gl.RG, gl.FLOAT, data.slice(2));
    });

    this.dopplerTexture = createTexture(gl, gl.TEXTURE_3D);
    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
    loadTextureData('doppler.dat', (data) => {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_3D, this.dopplerTexture);
      gl.texImage3D(gl.TEXTURE_3D, 0, gl.RGB32F, 64, 32, 64, 0, 
                    gl.RGB, gl.FLOAT, data);
    });

    this.blackbodyTexture = createTexture(gl, gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    loadTextureData('black_body.dat', (data) => {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.blackbodyTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB32F, 128, 1, 0,
                    gl.RGB, gl.FLOAT, data);
    });

    this.gridTexture = createTexture(gl, gl.TEXTURE_CUBE_MAP);
    gl.texStorage2D(gl.TEXTURE_CUBE_MAP, 10, gl.R8, 512, 512);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, 
                     gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);   
    gl.texParameterf(gl.TEXTURE_CUBE_MAP, ext.TEXTURE_MAX_ANISOTROPY_EXT, 
                     gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    const gridData = new Uint8Array(512 * 512);
    for (let j = 0; j < 512; ++j) {
      const jmod = (j + 2) % 32;
      for (let i = 0; i < 512; ++i) {
        const imod = (i + 2) % 32;
        gridData[i + j * 512] = (imod < 4 || jmod < 4) ? 255 : 0;
      }
    }
    for (let target of cubeMapTargets(gl)) {
      gl.texSubImage2D(target, 0, 0, 0, 512, 512, 
                       gl.RED, gl.UNSIGNED_BYTE, gridData, 0);
    }
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }

  loadStarTextures(glExt) {
    const gl = this.gl;

    this.galaxyTexture = createTexture(gl, gl.TEXTURE_CUBE_MAP);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.galaxyTexture);
    gl.texStorage2D(gl.TEXTURE_CUBE_MAP, 12, gl.RGB9_E5, 2048, 2048);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER,
                     gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);   
    gl.texParameterf(gl.TEXTURE_CUBE_MAP, glExt.TEXTURE_MAX_ANISOTROPY_EXT, 
                     gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));

    this.starTexture = createTexture(gl, gl.TEXTURE_CUBE_MAP);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.starTexture);
    gl.texStorage2D(gl.TEXTURE_CUBE_MAP, MAX_STAR_TEXTURE_LOD + 1, gl.RGB9_E5, 
                    2048, 2048);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, 
                     gl.NEAREST_MIPMAP_NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LOD, 
                     MAX_STAR_TEXTURE_LOD);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, 
                     MAX_STAR_TEXTURE_LOD);

    this.starTexture2 = createTexture(gl, gl.TEXTURE_CUBE_MAP);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.starTexture2);
    gl.texStorage2D(gl.TEXTURE_CUBE_MAP, 11 - MAX_STAR_TEXTURE_LOD, gl.RGB9_E5, 
                    2048 / (1 << (MAX_STAR_TEXTURE_LOD + 1)),
                    2048 / (1 << (MAX_STAR_TEXTURE_LOD + 1)));
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, 
                     gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameterf(gl.TEXTURE_CUBE_MAP, glExt.TEXTURE_MAX_ANISOTROPY_EXT, 
                     gl.getParameter(glExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));

    const base = '../../gaia_sky_map';
    const prefixes = ['pos-x', 'neg-x', 'pos-y', 'neg-y', 'pos-z', 'neg-z'];
    const targets = cubeMapTargets(gl);
    for (let l = 0; l <= 4; ++l) {
      for (let i = 0; i < 6; ++i) {
        const size = 2048 / (1 << l);
        const tileSize = Math.min(256, size);
        const numTiles = size / tileSize;
        for (let tj = 0; tj < numTiles; ++tj) {
          for (let ti = 0; ti < numTiles; ++ti) {
            const target = targets[i];
            const url = `${base}/${prefixes[i]}-${l}-${ti}-${tj}.dat`;
            this.tilesQueue.push({l, ti, tj, i, target, url});
          }
        }
      }
    }
    this.updateLoadingBar();
    this.loadStarTextureTiles();
  }

  loadStarTextureTiles() {
    while (this.tilesQueue.length > 0 && this.numPendingRequests < 6) {
      const tile = this.tilesQueue.pop();
      this.loadStarTextureTile(
          tile.l, tile.ti, tile.tj, tile.i, tile.target, tile.url);
    }
  }

  loadStarTextureTile(l, ti, tj, i, target, url) {
    const gl = this.gl;
    const size = 2048 / (1 << l);
    loadIntTextureData(url, (data) => {
      gl.activeTexture(gl.TEXTURE0);
      let start = 0;
      let level = l;
      let tileSize = Math.min(256, size);
      while (start < data.length) {
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.galaxyTexture);
        gl.texSubImage2D(target, level, ti * tileSize, tj * tileSize, 
            tileSize, tileSize, gl.RGB, gl.UNSIGNED_INT_5_9_9_9_REV, 
            data.subarray(start, start + tileSize * tileSize), 0);
        start += tileSize * tileSize;
        if (level <= MAX_STAR_TEXTURE_LOD) {
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.starTexture);
          gl.texSubImage2D(target, level, ti * tileSize, tj * tileSize, 
              tileSize, tileSize, gl.RGB, gl.UNSIGNED_INT_5_9_9_9_REV,
              data.subarray(start, start + tileSize * tileSize), 0);
        } else {
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.starTexture2);
          gl.texSubImage2D(target, level - (MAX_STAR_TEXTURE_LOD + 1), 
              ti * tileSize, tj * tileSize, tileSize, tileSize,
              gl.RGB, gl.UNSIGNED_INT_5_9_9_9_REV, 
              data.subarray(start, start + tileSize * tileSize), 0);
        }
        start += tileSize * tileSize;
        level += 1;
        tileSize /= 2;
      }
      this.numTilesLoaded += 1;
      if (l <= MAX_STAR_TEXTURE_LOD) {
        this.numTilesLoadedPerLevel[l] += 1;
      }
      this.numPendingRequests -= 1;
      this.updateLoadingBar();
      this.loadStarTextureTiles();
    });
    this.numPendingRequests += 1;
  }

  updateLoadingBar() {
    this.loadingBar.style.width = `${this.numTilesLoaded / 516 * 100}%`;
    if (this.numTilesLoaded == 516) {
      this.loadingPanel.classList.toggle('cv-loaded');
    }
  } 

  getMinLoadedStarTextureLod() {
    if (this.numTilesLoadedPerLevel[0] == 384) {
      return 0;
    } else if (this.numTilesLoadedPerLevel[1] == 96) {
      return 1;
    } else if (this.numTilesLoadedPerLevel[2] == 24) {
      return 2;
    } else if (this.numTilesLoadedPerLevel[3] == 6) {
      return 3;
    }
    return 4;
  }

  onKeyPress(event) {
    if (event.key == ' ') {
      this.loadingPanel.classList.toggle('cv-hidden');
    }
  }
}

BlackHoleShaderDemoApp.TextureManager = TextureManager;
})();

(function() {

// Max LOD for which the manul texture filtering method DefaultStarColor() in
// model.glsl must be used for stars. Above this level a default anisotropic
// texture filtering is used instead. Must be consistent with the same constant
// in texture_manager.js.
const MAX_STAR_TEXTURE_LOD = 6;

const generateDiscParticleParams = function() {
  const rMin = 3.0;
  const rMax = 12.0;
  const computeDthetaDphi = function(u1, u2, u3) {
    const k2 = (u2 - u1) / (u3 - u1);
    const N = 100000;
    let K = 0.0;
    for (let i = 0; i < N; ++i) {
      const dy = 1.0 / N;
      const y = (i + 0.5) / N;
      K += dy / Math.sqrt((1 - y * y) * (1 - k2 * y * y));
    }
    return Math.PI * Math.sqrt(u3 - u1) / (4 * K);
  };

  let ringParams = '';
  let numRings = 0;
  for (let r1 = rMin; r1 < rMax; r1 += 0.75) {
    const e = 0.1 * Math.random();
    const r2 = r1 * (1.0 + e) / (1.0 - e);
    const u1 = 1 / r2;
    const u2 = 1 / r1;
    const u3 = 1 - u1 - u2;
    const phi0 = 2 * Math.PI * Math.random();
    const dThetaDphi = computeDthetaDphi(u1, u2, u3);

    const x = u1.toPrecision(3);
    const y = u2.toPrecision(3);
    const z = phi0.toPrecision(3);
    const w = dThetaDphi.toPrecision(3);
    ringParams += `${numRings == 0 ? '' : ',\n'}vec4(${x}, ${y}, ${z}, ${w})`;
    numRings += 1;
  }

  return `
      const float INNER_DISC_R = ${rMin.toPrecision(3)};
      const float OUTER_DISC_R = ${rMax.toPrecision(3)};
      const int NUM_DISC_PARTICLES = ${numRings};
      const vec4 DISC_PARTICLE_PARAMS[${numRings}] = vec4[${numRings}] (
        ${ringParams}
      );`;
}

const createShader = function(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
};

class ShaderManager {
  constructor(model, textureManager, gl) {
    this.model = model;
    this.textureManager = textureManager;
    this.gl = gl;

    this.programs = {};
    this.program = null;
  }

  getProgram() {
    const options =
        `#define LENSING ${this.model.lensing.getValue() ? 1 : 0}
        #define DOPPLER ${this.model.doppler.getValue() ? 1 : 0}
        #define GRID ${this.model.grid.getValue() ? 1 : 0}
        #define STARS ${this.model.stars.getValue() ? 1 : 0}`;
    this.program = this.programs[options];
    if (this.program ||
        !this.textureManager.rayDeflectionTexture ||
        !this.textureManager.rayInverseRadiusTexture) {
      return this.program;
    }

    const header = 
        `#version 300 es
        precision highp float;
        #define IN(x) const in x
        #define OUT(x) out x
        ${options}
        const float pi = ${Math.PI};
        const float rad = 1.0;
        const int RAY_DEFLECTION_TEXTURE_WIDTH = 
            ${this.textureManager.rayDeflectionTexture.width};
        const int RAY_DEFLECTION_TEXTURE_HEIGHT =
            ${this.textureManager.rayDeflectionTexture.height};
        const int RAY_INVERSE_RADIUS_TEXTURE_WIDTH = 
            ${this.textureManager.rayInverseRadiusTexture.width};
        const int RAY_INVERSE_RADIUS_TEXTURE_HEIGHT = 
            ${this.textureManager.rayInverseRadiusTexture.height};
        const float STARS_CUBE_MAP_SIZE =
            float(${this.model.grid.getValue() ? 128 : 2048});
        const float MAX_FOOTPRINT_SIZE = float(4);
        const float MAX_FOOTPRINT_LOD =
            float(${this.model.grid.getValue() ? 0 : MAX_STAR_TEXTURE_LOD});\n`;

    const gl = this.gl;
    const vertexShader = createShader(
        gl, 
        gl.VERTEX_SHADER,
        `#version 300 es
        precision highp float;
        ${document.querySelector("#vertex_shader").innerHTML}`);

    const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        `${header}
        ${generateDiscParticleParams()} 
        ${document.querySelector("#black_hole_shader").innerHTML}
        ${document.querySelector("#fragment_shader").innerHTML}`);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    program.vertexAttrib = gl.getAttribLocation(program, 'vertex');
    program.cameraSize =
        gl.getUniformLocation(program, 'camera_size');
    program.cameraPosition =
        gl.getUniformLocation(program, 'camera_position');
    program.p =
        gl.getUniformLocation(program, 'p');
    program.kS =
        gl.getUniformLocation(program, 'k_s');
    program.eTau =
        gl.getUniformLocation(program, 'e_tau');
    program.eW =
        gl.getUniformLocation(program, 'e_w');
    program.eH =
        gl.getUniformLocation(program, 'e_h');
    program.eD =
        gl.getUniformLocation(program, 'e_d');
    program.rayDeflectionTexture = 
        gl.getUniformLocation(program, 'ray_deflection_texture');
    program.rayInverseRadiusTexture = 
        gl.getUniformLocation(program, 'ray_inverse_radius_texture');
    program.galaxyCubeTexture = 
        gl.getUniformLocation(program, 'galaxy_cube_texture');
    program.starCubeTexture = 
        gl.getUniformLocation(program, 'star_cube_texture');
    program.starCubeTexture2 = 
        gl.getUniformLocation(program, 'star_cube_texture2');
    program.starsOrientation =
        gl.getUniformLocation(program, 'stars_orientation');
    program.minStarsLod = 
        gl.getUniformLocation(program, 'min_stars_lod');
    program.blackBodyTexture = 
        gl.getUniformLocation(program, 'black_body_texture');
    program.dopplerTexture =
        gl.getUniformLocation(program, 'doppler_texture');
    program.noiseTexture = 
        gl.getUniformLocation(program, 'noise_texture');
    program.discParams =
        gl.getUniformLocation(program, 'disc_params');

    this.programs[options] = program;
    this.program = program;
    return program;
  }
}

BlackHoleShaderDemoApp.ShaderManager = ShaderManager;
})();

(function(model, Bloom, TextureManager, ShaderManager, RocketManager) {

const createQuadVertexBuffer = function(gl) {
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER,
       new Float32Array([-1, -1, +1, -1, -1, +1, +1, +1]), gl.STATIC_DRAW);
  return vertexBuffer;
};

class CameraView {
  constructor(model, rootElement) {
    this.model = model;
    this.rootElement = rootElement;
    this.devicePixelRatio = this.getDevicePixelRatio();
    this.canvas = rootElement.querySelector('#camera_view');
    this.canvas.style.width = `${rootElement.clientWidth}px`;
    this.canvas.style.height = `${rootElement.clientHeight}px`;
    this.canvas.width = rootElement.clientWidth * this.devicePixelRatio;
    this.canvas.height = rootElement.clientHeight * this.devicePixelRatio;
    this.errorPanel = rootElement.querySelector('#cv_error_panel');
    this.errorPanelShown = false;

    this.gl = this.canvas.getContext('webgl2');
    if (!this.initGl()) {
      return;
    }

    this.vertexBuffer = createQuadVertexBuffer(this.gl);
    this.textureManager = new TextureManager(rootElement, this.gl);
    this.shaderManager = new ShaderManager(model, this.textureManager, this.gl);
    this.rocketManager = new RocketManager(model, this.gl);
    this.bloom = new Bloom(this.gl, this.canvas.width, this.canvas.height);

    this.lastTauSeconds = Date.now() / 1000.0;
    this.lastFrameTime = undefined;
    this.numFrames = 0;

    this.drag = false;
    this.previousMouseX = undefined;
    this.previousMouseY = undefined;
    this.hidden = false;

    window.addEventListener('mousedown', (e) => this.onMouseDown(e));
    window.addEventListener('mousemove', (e) => this.onMouseMove(e));
    window.addEventListener('mouseup', (e) => this.onMouseUp(e));
    window.addEventListener('resize', (e) => this.onResize(e));
    document.addEventListener('visibilitychange', (e) => {
      this.hidden = document.hidden;
      if (!this.hidden) {
        this.lastFrameTime = undefined;
      }
    });

    requestAnimationFrame(() => this.onRender());
  }

  initGl() {
    if (!this.gl ||
        !this.gl.getExtension('OES_texture_float_linear') ||
        !this.gl.getExtension('EXT_texture_filter_anisotropic') ||
        !this.gl.getExtension('EXT_color_buffer_float') ||
        !this.gl.getExtension('EXT_float_blend')) {
      this.errorPanel.innerHTML = 'Unfortunately your browser doesn\'t ' + 
          'support WebGL 2 or the WebGL 2 extensions required for this demo.';
      this.errorPanel.classList.toggle('cv-hidden');
      return false;
    }
    this.errorPanel.addEventListener('click', () => {
      this.errorPanel.classList.toggle('cv-hidden');
    });
    return true;
  }

  onRender() {
    if (this.hidden) {
      return;
    }
    const program = this.shaderManager.getProgram();
    if (!program) {
      requestAnimationFrame(() => this.onRender());
      return;
    }
    if (this.devicePixelRatio != this.getDevicePixelRatio()) {
      this.onResize();      
    }

    const tauSeconds = Date.now() / 1000.0;
    const dTauSeconds = tauSeconds - this.lastTauSeconds;
    this.lastTauSeconds = tauSeconds;

    const tanFovY = Math.tan(this.model.fovY / 2);
    const focalLength = this.canvas.height / (2 * tanFovY);

    const gl = this.gl; 
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.textureManager.rayDeflectionTexture);      

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.textureManager.rayInverseRadiusTexture);

    gl.activeTexture(gl.TEXTURE2);
    if (this.model.grid.getValue()) {
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.textureManager.gridTexture);
    } else {
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.textureManager.galaxyTexture);
    }
    const minLod = this.model.grid.getValue() ?
        0 : this.textureManager.getMinLoadedStarTextureLod();
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_LOD, minLod);

    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.textureManager.starTexture);

    gl.activeTexture(gl.TEXTURE4);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.textureManager.starTexture2);

    gl.activeTexture(gl.TEXTURE5);
    gl.bindTexture(gl.TEXTURE_2D, this.textureManager.blackbodyTexture);

    gl.activeTexture(gl.TEXTURE6);
    gl.bindTexture(gl.TEXTURE_3D, this.textureManager.dopplerTexture);

    gl.activeTexture(gl.TEXTURE7);
    gl.bindTexture(gl.TEXTURE_2D, this.textureManager.noiseTexture);

    gl.useProgram(program);
    gl.uniform3f(program.cameraSize, 
        this.canvas.width / 2, this.canvas.height / 2, focalLength);
    gl.uniform4f(program.cameraPosition, 
        this.model.t, this.model.r, this.model.worldTheta, this.model.worldPhi);
    gl.uniform3f(program.p, this.model.p[0], this.model.p[1], this.model.p[2]);
    gl.uniform4f(program.kS, 
        this.model.kS[0], this.model.kS[1], this.model.kS[2], this.model.kS[3]);
    gl.uniform3f(program.eTau,
        this.model.eTau[1], this.model.eTau[2], this.model.eTau[3]);
    gl.uniform3f(program.eW,
        this.model.eW[1], this.model.eW[2], this.model.eW[3]);
    gl.uniform3f(program.eH,
        this.model.eH[1], this.model.eH[2], this.model.eH[3]);
    gl.uniform3f(program.eD,
        this.model.eD[1], this.model.eD[2], this.model.eD[3]);
    gl.uniform1i(program.rayDeflectionTexture, 0);
    gl.uniform1i(program.rayInverseRadiusTexture, 1); 
    gl.uniform1i(program.galaxyCubeTexture, 2);
    gl.uniform1i(program.starCubeTexture, 3);
    gl.uniform1i(program.starCubeTexture2, 4);
    gl.uniformMatrix3fv(program.starsOrientation, false, 
        this.model.starsMatrix);
    gl.uniform1f(program.minStarsLod, minLod);
    gl.uniform1i(program.blackBodyTexture, 5);
    gl.uniform1i(program.dopplerTexture, 6);
    gl.uniform1i(program.noiseTexture, 7);
    gl.uniform3f(program.discParams, 
        this.model.discDensity.getValue(),
        this.model.discOpacity.getValue(), 
        this.model.discTemperature.getValue());

    this.bloom.begin();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(program.vertexAttrib, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(program.vertexAttrib);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.disableVertexAttribArray(program.vertexAttrib);

    if (this.model.rocket.getValue()) {
      this.rocketManager.renderEnvMap(program, this.vertexBuffer);
      this.rocketManager.drawRocket();
      if (this.model.gForce > 0) {
        this.rocketManager.drawExhaust(tauSeconds, this.model.gForce);
      }
    }

    this.bloom.end(this.model.bloom.getValue(), this.model.exposure.getValue(),
        this.model.highContrast.getValue());

    this.model.updateOrbit(dTauSeconds);

    requestAnimationFrame(() => this.onRender());
    this.checkFrameRate();
  }

  checkFrameRate() {
    this.numFrames += 1;
    const time = Date.now();
    if (!this.lastFrameTime) {
      this.lastFrameTime = time;
      this.numFrames = 0;
    }
    if (time > this.lastFrameTime + 1000) {
      if (this.numFrames <= 10 && this.model.stars.getValue() && 
          !this.errorPanelShown) {
        this.model.stars.setValue(false);
        this.errorPanel.innerHTML = 'Stars have been automatically disabled ' +
            'to improve performance. You can re-enable them from the left ' +
            'hand side panel.';
        this.errorPanel.classList.toggle('cv-hidden');
        this.errorPanel.classList.toggle('cv-warning');
        this.errorPanelShown = true;
      }
      this.lastFrameTime = time;
      this.numFrames = 0;
    }
  }

  onMouseDown(event) {
    this.previousMouseX = event.screenX;
    this.previousMouseY = event.screenY;
    this.drag = (event.target.tagName != 'INPUT') && !event.ctrlKey;
  }

  onMouseMove(event) {
    const mouseX = event.screenX;
    const mouseY = event.screenY;
    if (this.drag) {
      const kScale = 500;
      let yaw = this.model.cameraYaw.getValue();
      let pitch = this.model.cameraPitch.getValue();
      yaw += (this.previousMouseX - mouseX) / kScale;
      pitch -= (this.previousMouseY - mouseY) / kScale;
      this.model.cameraYaw.setValue(
          yaw - 2 * Math.PI * Math.floor(yaw / (2 * Math.PI)));
      this.model.cameraPitch.setValue(pitch);
    }
    this.previousMouseX = mouseX;
    this.previousMouseY = mouseY;
  }

  onMouseUp(event) {
    this.drag = false;
  }

  onResize(event) {
    const rootElement = this.rootElement;
    this.devicePixelRatio = this.getDevicePixelRatio();
    this.canvas.style.width = `${rootElement.clientWidth}px`;
    this.canvas.style.height = `${rootElement.clientHeight}px`;
    this.canvas.width = rootElement.clientWidth * this.devicePixelRatio;
    this.canvas.height = rootElement.clientHeight * this.devicePixelRatio;
    this.bloom.resize(this.canvas.width, this.canvas.height);
  }

  getDevicePixelRatio() {
    return this.model.highDefinition.getValue() ? window.devicePixelRatio : 1;
  }
}

window.addEventListener('DOMContentLoaded', () => {
  new CameraView(model, document.body);
});
})(BlackHoleShaderDemoApp.model,
    BlackHoleShaderDemoApp.Bloom,
    BlackHoleShaderDemoApp.TextureManager,
    BlackHoleShaderDemoApp.ShaderManager,
    BlackHoleShaderDemoApp.RocketManager);

(function(model) {

class Context3d {
  constructor(canvas) {
    this.canvas = canvas;
    this.context = canvas.getContext('2d');

    const r = 120;
    const theta = 70 * Math.PI / 180;
    const phi = -135 * Math.PI / 180;
    const fovY = 30 * Math.PI / 180;

    this.ex = [-Math.sin(phi), Math.cos(phi), 0];
    this.ey = [-Math.cos(theta) * Math.cos(phi),
               -Math.cos(theta) * Math.sin(phi),
                Math.sin(theta)];
    this.ez = [Math.sin(theta) * Math.cos(phi),
               Math.sin(theta) * Math.sin(phi),
               Math.cos(theta)];
    this.camera = [r * this.ez[0], r * this.ez[1], r * this.ez[2]];

    this.width = canvas.width;
    this.height = canvas.height;
    this.focal = this.height / (2 * Math.tan(fovY / 2));
    this.nearPlane = -0.1;
    this.lastCameraPt = [];
  }

  moveTo(x, y, z) {
    this.pathTo(x, y, z, true);
  }

  lineTo(x, y, z) {
    this.pathTo(x, y, z, false);
  }

  pathTo(x, y, z, move) {
    const cameraPt = this.toCameraPt([x, y, z]);
    const screenPt = this.toScreenPt(cameraPt);
    if (move) {
      this.context.moveTo(screenPt[0], screenPt[1]);
    } else {
      if (cameraPt[2] < this.nearPlane) {
        if (this.lastCameraPt[2] > this.nearPlane) {
          this.clipTo(cameraPt, true);
        }
        this.context.lineTo(screenPt[0], screenPt[1]);
      } else if (this.lastCameraPt[2] < this.nearPlane) {
        this.clipTo(cameraPt, false);
      }
    }
    this.lastCameraPt = cameraPt;
  }

  clipTo(cameraPt, move) {
    const t = (this.nearPlane - this.lastCameraPt[2]) / 
        (cameraPt[2] - this.lastCameraPt[2]);
    const nearPlanePt = [
        this.lastCameraPt[0] + t * (cameraPt[0] - this.lastCameraPt[0]),
        this.lastCameraPt[1] + t * (cameraPt[1] - this.lastCameraPt[1]),
        this.nearPlane];
    const screenPt = this.toScreenPt(nearPlanePt);
    if (move) {
      this.context.moveTo(screenPt[0], screenPt[1]);
    } else {
      this.context.lineTo(screenPt[0], screenPt[1]);
    }
  }

  toCameraPt(worldPt) {
    const q = [worldPt[0] - this.camera[0],
               worldPt[1] - this.camera[1],
               worldPt[2] - this.camera[2]];
    return [q[0] * this.ex[0] + q[1] * this.ex[1] + q[2] * this.ex[2],
            q[0] * this.ey[0] + q[1] * this.ey[1] + q[2] * this.ey[2],
            q[0] * this.ez[0] + q[1] * this.ez[1] + q[2] * this.ez[2]];
  }

  toScreenPt(cameraPt) {
    return [this.width * 0.5 - 0.5 * this.focal * cameraPt[0] / cameraPt[2],
            this.height * 0.5 + 0.5 * this.focal * cameraPt[1] / cameraPt[2]];
  }
}

const safeSqrt = function(x) {
  return Math.sqrt(Math.max(x, 0));
};

class OrbitPanel {
  constructor(rootElement, model) {
    this.rootElement = rootElement;
    this.model = model;
    this.model.addListener(this);

    this.blackHoleRadius = rootElement.querySelector('#op_black_hole_radius');
    this.radius = rootElement.querySelector('#op_radius');
    this.speed = rootElement.querySelector('#op_speed');
    this.gforce = rootElement.querySelector('#op_gforce');
    this.localTime = rootElement.querySelector('#op_local_time');
    this.globalTime = rootElement.querySelector('#op_global_time');
    this.timeDilation = rootElement.querySelector('#op_time_dilation');
    this.dot = rootElement.querySelector('#op_dot');
    this.frustum = [];
    for (let i = 0; i <= 8; ++i) {
      this.frustum.push(rootElement.querySelector(`#op_frustum${i}`));
    }
    this.numberFormat = 
        new Intl.NumberFormat('en-US', {maximumFractionDigits : 1});

    this.lastStartRadius = undefined;
    this.lastStartDirection = undefined;
    this.lastStartSpeed = undefined;
    this.lastOrbitInclination = undefined;

    this.canvas = rootElement.querySelector('#canvas');
    this.context = this.canvas.getContext('2d');
    this.context3d = new Context3d(this.canvas);

    this.onSettingsChange();
    this.onOrbitChange();
    this.toggleVisibility();

    document.body.addEventListener('keypress', (e) => this.onKeyPress(e));
  }

  onSettingsChange() {
    if (this.lastStartRadius == this.model.startRadius.getValue() &&
        this.lastStartDirection == this.model.startDirection.getValue() &&
        this.lastStartSpeed == this.model.startSpeed.getValue() &&
        this.lastOrbitInclination == this.model.orbitInclination.getValue()) {
      return;
    }
    this.lastStartRadius = this.model.startRadius.getValue();
    this.lastStartDirection = this.model.startDirection.getValue();
    this.lastStartSpeed = this.model.startSpeed.getValue();
    this.lastOrbitInclination = this.model.orbitInclination.getValue();

    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.context.strokeStyle = '#AAA';
    this.context.beginPath();
    this.drawGrid(100, 12, this.model.orbitInclination.getValue());
    this.context.stroke();    
    this.drawAxes();
    this.drawDisc();
    this.drawOrbit();
  }

  onOrbitChange() {
    const model = this.model;
    const radiusMeters = model.r * model.blackHoleRadiusMeters;
    this.blackHoleRadius.innerText =
        `${this.numberFormat.format(model.blackHoleRadiusMeters / 1000)}km`;
    this.radius.innerText = 
        `${this.numberFormat.format(radiusMeters / 1000)}km`;
    this.speed.innerText = 
        `${this.numberFormat.format(model.speedMetersPerSecond / 1000)}km/s`;
    this.gforce.innerText = 
        `${this.numberFormat.format(model.gForce / 9.80665)}g`;
    this.localTime.innerText = 
        `${model.localElapsedTimeSeconds.toFixed(2)}s`;
    this.globalTime.innerText = 
        `${model.globalElapsedTimeSeconds.toFixed(2)}s`;
    this.timeDilation.innerText = 
        `${model.timeDilationFactor.toFixed(3)}`;

    this.drawDotAndFrustum();
  }

  drawDotAndFrustum() {
    const model = this.model;
    const context3d = this.context3d;
    const ci = Math.cos(model.orbitInclination.getValue());
    const si = Math.sin(model.orbitInclination.getValue());
    const worldPt = [ci * model.r * Math.cos(model.phi),
                          model.r * Math.sin(model.phi),
                     si * model.r * Math.cos(model.phi)];
    const screenPt = context3d.toScreenPt(context3d.toCameraPt(worldPt));
    this.dot.style.left = `${screenPt[0]}px`;
    this.dot.style.top = `${screenPt[1]}px`;
 
    const tanFovY = Math.tan(model.fovY / 2);
    const focalLength = 1 / (2 * tanFovY);
    const aspectRatio = document.body.clientWidth / document.body.clientHeight;
    const eTau = model.eTau;
    const eW = model.eW;
    const eH = model.eH;
    const eD = model.eD;
    const getFrustumScreenPt = function(i, j, l) {
      const w = i * aspectRatio;
      const h = j;
      const d = -focalLength;
      const n = Math.sqrt(w * w + h * h + d * d);
      const dx = -eTau[1] + (w * eW[1] + h * eH[1] + d * eD[1]) / n;
      const dy = -eTau[2] + (w * eW[2] + h * eH[2] + d * eD[2]) / n;
      const dz = -eTau[3] + (w * eW[3] + h * eH[3] + d * eD[3]) / n;
      const dl = Math.sqrt(dx * dx + dy * dy + dz * dz);
      const frustumWorldPt = [
        worldPt[0] + l * dx / dl,
        worldPt[1] + l * dy / dl,
        worldPt[2] + l * dz / dl
      ];
      return context3d.toScreenPt(context3d.toCameraPt(frustumWorldPt));
    };
    const frustumScreenPts = [
      getFrustumScreenPt(-1, -1, 10),
      getFrustumScreenPt(-1, 1, 10),
      getFrustumScreenPt(1, 1, 10),
      getFrustumScreenPt(1, -1, 10),
      getFrustumScreenPt(0, 0, 10)
    ];
    for (let i = 0; i < 4; ++i) {
      this.setLine(this.frustum[i], screenPt, frustumScreenPts[i]);
      this.setLine(this.frustum[i + 4], frustumScreenPts[i], 
          frustumScreenPts[(i + 1) % 4]);
    }
    this.setLine(this.frustum[8], screenPt, frustumScreenPts[4]);
  }

  setLine(element, p, q) {
    const dx = q[0] - p[0];
    const dy = q[1] - p[1];
    const scale = Math.sqrt(dx * dx + dy * dy);
    const theta = Math.atan2(dy, dx);
    const a = scale * Math.cos(theta);
    const b = scale * Math.sin(theta);
    const c = -Math.sin(theta);
    const d = Math.cos(theta);
    const tx = p[0];
    const ty = p[1];
    element.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`;
  }

  drawGrid(halfSize, steps, orbitInclination) {
    const ci = Math.cos(orbitInclination);
    const si = Math.sin(orbitInclination);
    for (let i = 0; i <= steps; ++i) {
      const step = -halfSize + 2 * (i / steps) * halfSize;
      this.context3d.moveTo(-ci * halfSize, step, -si * halfSize);
      this.context3d.lineTo(ci * halfSize, step, si * halfSize);
      this.context3d.moveTo(ci * step, -halfSize, si * step);
      this.context3d.lineTo(ci * step, halfSize, si * step);
    }
  }

  drawAxes() {
    const context = this.context;
    const context3d = this.context3d;
    context.strokeStyle = '#F00';
    context.beginPath();
    context3d.moveTo(0, 0, 0);
    context3d.lineTo(40, 0, 0);
    context.stroke(); 
    context.strokeStyle = '#0F0';
    context.beginPath();
    context3d.moveTo(0, 0, 0);
    context3d.lineTo(0, 40, 0);
    context.stroke(); 
    context.strokeStyle = '#00F';
    context.beginPath();
    context3d.moveTo(0, 0, 0);
    context3d.lineTo(0, 0, 40);
    context.stroke(); 
  }

  drawDisc() {
    const context = this.context;
    context.strokeStyle = '#FF0';
    context.lineWidth = 2;
    context.beginPath();
    this.drawCircle(3);
    this.drawCircle(12);
    context.stroke();
    context.lineWidth = 1;
  }

  drawCircle(radius) {
    this.context3d.moveTo(radius, 0, 0);
    for (let i = 1; i <= 64; ++i) {
      const a = 2 * Math.PI * i / 64;
      this.context3d.lineTo(radius * Math.cos(a), radius * Math.sin(a), 0);
    }
  }

  drawOrbit() {
    const context = this.context;
    context.lineWidth = 2;
    context.strokeStyle = '#FFF';
    context.shadowOffsetX = 1;
    context.shadowOffsetY = 1;
    context.shadowBlur = 2;
    context.shadowColor = '#000';
    context.beginPath();
    const ci = Math.cos(this.model.orbitInclination.getValue());
    const si = Math.sin(this.model.orbitInclination.getValue());
    const e = this.model.e;
    const l = this.model.l;
    let r = this.model.startRadius.getValue();
    let u = 1 / r;
    let drOverDtau = -safeSqrt(e * e - (1 - u) - l * l * u * u * (1 - u));
    let phi = 0;

    let i = 0;
    let dashes = false;
    this.context3d.moveTo(ci * r, 0, si * r);
    while (Math.abs(phi) < 6 * Math.PI) {
      u = 1 / r;
      // Adaptive integration step size, chosen such that the proper distance
      // ds^2 = dr^2 / (1 - u) + r^2 dPhi^2 = dTau^2 (e^2 / (1 - u) - 1) is
      // constant at each step.
      const dTau = 1e-2 / Math.sqrt(e * e / (1 - u) - 0.99);
      const d2rOverDtau2 = u * u * (l * l * u * (2 - 3 * u) - 1) / 2;
      drOverDtau += d2rOverDtau2 * dTau;
      r += drOverDtau * dTau;
      phi += l * u * u * dTau;
      if (r > 100.0 || r <= 1.0) {
        break;
      }
      if ((++i) % 100 == 0) {
        const x = r * Math.cos(phi);
        const y = r * Math.sin(phi);
        this.context3d.lineTo(ci * x, y, si * x);
        if (Math.abs(phi) > 5 * Math.PI && !dashes) {
          context.stroke(); 
          context.beginPath();
          this.context3d.moveTo(ci * x, y, si * x);
          context.setLineDash([5, 5]);
          dashes = true;
        }
      }
    }
    context.stroke(); 
    context.lineWidth = 1;
    context.setLineDash([]);
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    context.shadowBlur = 0;
  }

  onKeyPress(event) {
    if (event.key == ' ') {
      this.toggleVisibility();
    }
  }

  toggleVisibility() {
    this.rootElement.classList.toggle('op-hidden');
  }
}

window.addEventListener('DOMContentLoaded', () => {
  new OrbitPanel(document.body.querySelector('#orbit_panel'), model);
});
})(BlackHoleShaderDemoApp.model);

(function(model, State) {

class Checkbox {
  constructor(rootElement, name, model) {
    this.checkbox = rootElement.querySelector(`#sp_${name}`);
    this.checkbox.addEventListener('input', () => {
      model.setValue(this.checkbox.checked);
    });
    this.model = model;
  }
  update() {
    this.checkbox.checked = this.model.getValue();
  }
}

class Slider {
  constructor(rootElement, name, model) {
    this.slider = rootElement.querySelector(`#sp_${name}`);
    this.value = rootElement.querySelector(`#sp_${name}_value`);
    this.model = model;

    this.slider.min = 0;
    this.slider.max = model.getSize();
    this.slider.addEventListener('input', () => {
      model.setIndex(parseInt(this.slider.value));
    });
    this.slider.previousElementSibling.addEventListener('click', () => {
      model.setIndex(model.getIndex() - 1);
    });
    this.slider.nextElementSibling.addEventListener('click', () => {
      model.setIndex(model.getIndex() + 1);
    });
  }
  getValue() { return this.model.getValue(); }
  setValue(value) { this.model.setValue(value); }
  enable(enabled) {
    this.slider.disabled = !enabled;
    this.slider.previousElementSibling.disabled = !enabled;
    this.slider.nextElementSibling.disabled = !enabled;
  }  
  update(format) {
    this.slider.value = this.model.getIndex();
    this.value.innerText = format(this.model.getValue());
  }
}

const quaternionFromAxisAngle = function(x, y, z, theta) {
  const ct = Math.cos(theta * 0.5);
  const st = Math.sin(theta * 0.5);
  return [ct, st * x, st * y, st * z];
};

const quaternionFromEulerAngles = function(yaw, pitch, roll) {
  const cy = Math.cos(yaw * 0.5);
  const sy = Math.sin(yaw * 0.5);
  const cp = Math.cos(pitch * 0.5);
  const sp = Math.sin(pitch * 0.5);
  const cr = Math.cos(roll * 0.5);
  const sr = Math.sin(roll * 0.5);
  return [
    cy * cp * cr + sy * sp * sr,
    cy * cp * sr - sy * sp * cr,
    sy * cp * sr + cy * sp * cr,
    sy * cp * cr - cy * sp * sr];
};

const quaternionProduct = function(q1, q2) {
  return [
    q1[0] * q2[0] - q1[1] * q2[1] - q1[2] * q2[2] - q1[3] * q2[3],
    q1[0] * q2[1] + q1[1] * q2[0] + q1[2] * q2[3] - q1[3] * q2[2],
    q1[0] * q2[2] - q1[1] * q2[3] + q1[2] * q2[0] + q1[3] * q2[1],
    q1[0] * q2[3] + q1[1] * q2[2] - q1[2] * q2[1] + q1[3] * q2[0]
  ];
};

const quaternionToEulerAngles = function(qw, qx, qy, qz) {
  const sinr_cosp = 2 * (qw * qx + qy * qz);
  const cosr_cosp = 1 - 2 * (qx * qx + qy * qy);
  const roll = Math.atan2(sinr_cosp, cosr_cosp);
  const sinp = 2 * (qw * qy - qz * qx);
  let pitch;
  if (Math.abs(sinp) >= 1) {
    pitch = sinp > 0 ? Math.PI / 2 : -Math.PI / 2;
  } else {
    pitch = Math.asin(sinp);
  }
  const siny_cosp = 2 * (qw * qz + qx * qy);
  const cosy_cosp = 1 - 2 * (qy * qy + qz * qz);
  const yaw = Math.atan2(siny_cosp, cosy_cosp);
  return [yaw, pitch, roll];
}

class SettingsPanel {
  constructor(rootElement, model) {
    this.rootElement = rootElement;
    this.model = model;
    this.model.addListener(this);

    if (window.devicePixelRatio <= 1) {
      const highDefinitionDiv =
          this.rootElement.querySelector('#sp_high_definition_div');
      highDefinitionDiv.classList.toggle('sp-hidden', true);
    }

    this.cameraTarget = this.rootElement.querySelector('#sp_target_container');
    this.exposure =
        new Slider(rootElement, 'exposure', model.exposure);
    this.bloom = 
        new Slider(rootElement, 'bloom', model.bloom);
    this.highDefinition =
        new Checkbox(rootElement, 'high_definition', model.highDefinition);
    this.highContrast =
        new Checkbox(rootElement, 'high_contrast', model.highContrast);
    this.startRadius = 
        new Slider(rootElement, 'start_radius', model.startRadius);
    this.startDirection = 
        new Slider(rootElement, 'start_direction', model.startDirection);
    this.startSpeed = 
        new Slider(rootElement, 'start_speed', model.startSpeed);
    this.orbitInclination = 
        new Slider(rootElement, 'orbit_inclination', model.orbitInclination);
    this.lensing =
        new Checkbox(rootElement, 'lensing', model.lensing);
    this.doppler = 
        new Checkbox(rootElement, 'doppler', model.doppler);
    this.grid = 
        new Checkbox(rootElement, 'grid', model.grid);
    this.blackHoleMass = 
        new Slider(rootElement, 'black_hole_mass', model.blackHoleMass);
    this.discDensity =
        new Slider(rootElement, 'disc_density', model.discDensity);
    this.discOpacity =
        new Slider(rootElement, 'disc_opacity', model.discOpacity);
    this.discTemperature =
        new Slider(rootElement, 'disc_temperature', model.discTemperature);
    this.rocketDistance =
        new Slider(rootElement, 'rocket_distance', model.rocketDistance);
    this.rocket = 
        new Checkbox(rootElement, 'rocket', model.rocket);
    this.starsYaw =
        new Slider(rootElement, 'stars_yaw', model.starsYaw);
    this.starsPitch =
        new Slider(rootElement, 'stars_pitch', model.starsPitch);
    this.starsRoll =
        new Slider(rootElement, 'stars_roll', model.starsRoll);
    this.stars = 
        new Checkbox(rootElement, 'stars', model.stars);
    this.previousMouseX = undefined;
    this.previousMouseY = undefined;
    this.drag = false;

    this.onSettingsChange();
    this.onOrbitChange();
    this.toggleVisibility();

    for (let i = 0; i < 5; ++i) {
      this.rootElement.querySelector(`#sp_target${i}`).addEventListener(
          'click', (e) => this.setCameraTarget(i));
    }
    this.rootElement.querySelector('#sp_play').addEventListener(
        'click', (e) => this.model.setState(State.PLAYING));
    this.rootElement.querySelector('#sp_play').addEventListener(
        'click', (e) => this.model.setState(State.PLAYING));
    this.rootElement.querySelector('#sp_pause').addEventListener(
        'click', (e) => this.model.setState(State.PAUSED));
    this.rootElement.querySelector('#sp_stop').addEventListener(
        'click', (e) => this.model.setState(State.STOPPED));
    document.body.addEventListener('keypress', (e) => this.onKeyPress(e));
    document.body.addEventListener('wheel', (e) => this.onMouseWheel(e));
    window.addEventListener('mousedown', (e) => this.onMouseDown(e));
    window.addEventListener('mousemove', (e) => this.onMouseMove(e));
    window.addEventListener('mouseup', (e) => this.onMouseUp(e));
  }

  onSettingsChange() {
    this.cameraTarget.setAttribute('select', 
        this.model.cameraYaw.getValue() == 0 && 
        this.model.cameraPitch.getValue() == 0 ? 
            `${this.model.cameraTarget.getValue()}` : '');
    this.exposure.update((v) => `${(Math.log2(v * 1000)).toPrecision(3)}`);
    this.bloom.update((v) => `${(v * 100).toFixed(0)}%`);
    this.highDefinition.update();
    this.highContrast.update();
    this.startRadius.update((v) => `${v.toPrecision(3)}`);
    this.startDirection.update((v) => `${(v * 180 / Math.PI).toFixed(1)}°`);
    this.startSpeed.update((v) => `${v.toPrecision(3)}`);
    this.orbitInclination.update((v) => `${(v * 180 / Math.PI).toFixed(1)}°`);
    this.lensing.update();
    this.doppler.update();
    this.grid.update();
    this.blackHoleMass.update((v) => `${v.toExponential(2)}`);
    this.discDensity.update((v) => `${v.toExponential(2)}`);
    this.discOpacity.update((v) => `${(v * 100).toFixed(1)}%`);
    this.discTemperature.update((v) => `${v.toFixed(0)}K`);
    this.rocketDistance.update((v) => `${v.toFixed(1)}m`);
    this.rocket.update();
    this.starsYaw.update((v) => `${(v * 180 / Math.PI).toFixed(1)}°`);
    this.starsPitch.update((v) => `${(v * 180 / Math.PI).toFixed(1)}°`);
    this.starsRoll.update((v) => `${(v * 180 / Math.PI).toFixed(1)}°`);
    this.stars.update();
  }

  onOrbitChange() {
    const playing = this.model.state == State.PLAYING;
    this.rootElement.classList.toggle('sp-playing', playing);

    const stopped = this.model.state == State.STOPPED;
    this.startRadius.enable(stopped);
    this.startDirection.enable(stopped);
    this.startSpeed.enable(stopped);
  }

  onKeyPress(event) {
    const key = event.key;
    if (key == '+') {
      this.exposure.setValue(this.exposure.getValue() * 1.1);
    } else if (key == '-') {
      this.exposure.setValue(this.exposure.getValue() / 1.1);
    } else if (key == 'p') {
      this.model.setState(
          this.model.state == State.PLAYING ? State.PAUSED : State.PLAYING); 
    } else if (key == 'd') {
      this.setCameraTarget(0);
    } else if (key == 'b') {
      this.setCameraTarget(1);
    } else if (key == 'l') {
      this.setCameraTarget(2);
    } else if (key == 'f') {
      this.setCameraTarget(3);
    } else if (key == 'r') {
      this.setCameraTarget(4);
    } else if (key == ' ') {
      this.toggleVisibility();
    }
  }

  onMouseWheel(event) {
    if (this.model.state == State.STOPPED) {
      if (event.deltaY > 0) {
        this.startRadius.setValue(this.startRadius.getValue() * 1.05);
      } else {
        this.startRadius.setValue(this.startRadius.getValue() / 1.05);
      }
    }
  }

  onMouseDown(event) {
    this.previousMouseX = event.screenX;
    this.previousMouseY = event.screenY;
    this.drag = (event.target.tagName != 'INPUT') && event.ctrlKey;
  }

  onMouseMove(event) {
    const kScale = 500;
    const mouseX = event.screenX;
    const mouseY = event.screenY;
    if (this.drag) {
      const x = (this.previousMouseX - mouseX) / kScale;
      const y = (this.previousMouseY - mouseY) / kScale;
      const qx = quaternionFromAxisAngle(0, 0, 1, -x);
      const qy = quaternionFromAxisAngle(0, 1, 0, y);
      let q = quaternionFromEulerAngles(this.model.starsYaw.getValue(), 
          this.model.starsPitch.getValue(), this.model.starsRoll.getValue());    
      q = quaternionProduct(q, qx);
      q = quaternionProduct(q, qy);
      const euler = quaternionToEulerAngles(q[0], q[1], q[2], q[3]);
      this.model.starsYaw.setValue(euler[0]);
      this.model.starsPitch.setValue(euler[1]);
      this.model.starsRoll.setValue(euler[2]);
    }
    this.previousMouseX = mouseX;
    this.previousMouseY = mouseY;
  }

  onMouseUp(event) {
    this.drag = false;
  }

  setCameraTarget(target) {
    this.model.cameraTarget.setValue(target);
    this.model.cameraYaw.setValue(0);
    this.model.cameraPitch.setValue(0);
  }

  toggleVisibility() {
    this.rootElement.classList.toggle('sp-hidden');
  }
}

window.addEventListener('DOMContentLoaded', () => {
  new SettingsPanel(document.body.querySelector('#settings_panel'), model);
});
})(BlackHoleShaderDemoApp.model, BlackHoleShaderDemoApp.State);
    </script>
  </head>
  <body>
    <script type="x-shader/x-vertex" id="exhaust_vertex_shader">

uniform mat4 model_view_proj_matrix;

layout(location = 0) in vec3 position_attribute;

out vec3 position;

void main() {
  position = position_attribute;
  gl_Position = model_view_proj_matrix * vec4(position, 1.0);
}
    </script>
    <script type="x-shader/x-fragment" id="exhaust_fragment_shader">

uniform vec3 camera;

uniform vec3 intensity;
uniform vec3 k_r;
uniform vec3 k_z;

in vec3 position;

layout(location = 0) out vec4 frag_color;

void main() {
  frag_color = vec4(0.0);

  vec3 dir = normalize(position - camera);
  float a = dot(dir.xy, dir.xy);
  float b = dot(camera.xy, dir.xy);
  float c = dot(camera.xy, camera.xy);
  float discriminant = b * b - a * (c - RADIUS * RADIUS);
  if (discriminant >= 0.0) {
    float t_min = max((-b - sqrt(discriminant)) / a, 0.0);
    float t_max = (-b + sqrt(discriminant)) / a;
    if (dir.z > 0.0) {
      t_min = max(t_min, (Z_MIN - camera.z) / dir.z);
      t_max = min(t_max, (Z_MAX - camera.z) / dir.z);
    } else {
      t_min = max(t_min, (Z_MAX - camera.z) / dir.z);
      t_max = min(t_max, (Z_MIN - camera.z) / dir.z);
    }
    if (t_min < t_max) {
      const int N = 16;
      vec3 emitted = vec3(0.0);
      float dt = (t_max - t_min) / float(N);
      float t = t_min + 0.5 * dt;
      // TODO(me): use analytic indefinite integral instead?
      for (int i = 0; i < N; ++i) {
        float r2 = ((a * t + 2.0 * b) * t) + c;
        float z = camera.z + t * dir.z;
        emitted += exp(- k_r * r2 - k_z * (Z_MAX - z));
        t += dt;
      }
      frag_color = vec4(intensity * emitted * dt, 0.0);
    }
  }
}
    </script>
    <script type="x-shader/x-vertex" id="rocket_vertex_shader">

uniform mat4 model_view_proj_matrix;

layout(location = 0) in vec3 position_attribute;
layout(location = 1) in vec3 normal_attribute;
layout(location = 2) in vec4 tangent_attribute;
layout(location = 3) in vec2 uv_attribute;
layout(location = 4) in float ambient_occlusion_attribute;

out vec3 position;
out vec3 normal;
out vec3 tangent;
out vec2 uv;
out float ambient_occlusion;

void main() {
  position = position_attribute;
  normal = normal_attribute;
  tangent = tangent_attribute.xyz;
  uv = uv_attribute;
  ambient_occlusion = ambient_occlusion_attribute;
  gl_Position = model_view_proj_matrix * vec4(position, 1.0);
}
    </script>
    <script type="x-shader/x-fragment" id="rocket_fragment_shader">

const float PI = 3.141592653589793;

// First few terms of the Van Der Corput sequence.
const float VAN_DER_CORPUT[32] = float[32](
  0.00000, 0.50000, 0.25000, 0.75000, 0.12500, 0.62500, 0.37500, 0.87500,
  0.06250, 0.56250, 0.31250, 0.81250, 0.18750, 0.68750, 0.43750, 0.93750,
  0.03125, 0.53125, 0.28125, 0.78125, 0.15625, 0.65625, 0.40625, 0.90625,
  0.09375, 0.59375, 0.34375, 0.84375, 0.21875, 0.71875, 0.46875, 0.96875
);

uniform vec3 camera;
uniform sampler2D base_color_texture;
uniform sampler2D occlusion_roughness_metallic_texture;
uniform sampler2D normal_map_texture;
uniform samplerCube env_map_texture;

in vec3 position;           // position, in object space.
in vec3 normal;             // geometric normal, in object space.
in vec3 tangent;            // geometric tangent, in object space.
in vec2 uv;
in float ambient_occlusion; // 0 = full occlusion, 1 = no occlusion.

layout(location = 0) out vec4 frag_color;

// The following uses the notations and equations in Appendix B of
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0

struct Surface {
  vec3 n;              // perturbed normal, in object space.
  vec3 tx;             // perturbed tangent, in object space.
  vec3 ty;             // perturbed bitangent, in object space.
  float occlusion;     // 0 = full occlusion, 1 = no occlusion.
  float alpha_sq;      // fourth power of 'roughness'.
  vec3 albedo;         // surface diffuse albedo.
  vec3 f0;             // surface reflection ratio.
};

// Returns the perturbed normal in object space.
vec3 ComputeNormal() {
  // Perturbed normal, in geometric tangent space.
  vec3 n = texture(normal_map_texture, uv).xyz * 2.0 - vec3(1.0);
  // Basis vectors of the geometric tangent space, in object space.
  vec3 ez = normalize(normal);
  vec3 ex = normalize(tangent);
  vec3 ey = cross(ez, ex);
  return normalize(n.x * ex + n.y * ey + n.z * ez);
}

// Returns the parameters of the surface.
Surface ComputeSurface() {
  Surface surface;
  surface.n = ComputeNormal();
  surface.ty = normalize(cross(surface.n, tangent));
  surface.tx = cross(surface.ty, surface.n);

  vec3 occlusion_roughness_metallic =
      texture(occlusion_roughness_metallic_texture, uv).rgb;
  surface.occlusion = occlusion_roughness_metallic.r * ambient_occlusion;
  float roughness = occlusion_roughness_metallic.g;
  float metallic = occlusion_roughness_metallic.b;
  float alpha = roughness * roughness;
  surface.alpha_sq = alpha * alpha;

  const float DIELECTRIC_F0 = 0.04;
  const vec3 METAL_ALBEDO = vec3(0.0);
  vec3 color = texture(base_color_texture, uv).rgb;
  surface.albedo = mix(color * (1.0 - DIELECTRIC_F0), METAL_ALBEDO, metallic);
  surface.f0 = mix(vec3(DIELECTRIC_F0), color, metallic);
  
  return surface;
}

// Returns the object space coordinates of a vector specified by its spherical
// coordinates in the perturbed tangent space of the surface.
vec3 GetVector(Surface surface, float cos_theta, float sin_theta, float phi) {
  float vx = sin_theta * cos(phi);
  float vy = sin_theta * sin(phi);
  float vz = cos_theta;
  return vx * surface.tx + vy * surface.ty + vz * surface.n;
}

// Surface reflection ratio F.
vec3 Fresnel(vec3 f0, float v_dot_h) {
  return f0 + (vec3(1.0) - f0) * pow(1.0 - v_dot_h, 5.0);
}

// Geometric occlusion term G divided by 4 (n.l) (n.v).
float MicroFacetVisibility(float alpha_sq, float n_dot_l, float n_dot_v) {
  float a = n_dot_l * sqrt(n_dot_v * n_dot_v * (1.0 - alpha_sq) + alpha_sq);
  float b = n_dot_v * sqrt(n_dot_l * n_dot_l * (1.0 - alpha_sq) + alpha_sq);
  return 0.5 / (a + b);
}

// Microfacet distribution D.
float MicroFacetDistribution(float alpha_sq, float n_dot_h) {
  float a = n_dot_h * n_dot_h * (alpha_sq - 1.0) + 1.0;
  return alpha_sq / (PI * a * a);
}

vec3 ImageBasedLighting(Surface surface, vec3 v) {
  // Compute the lighting integral with N_Z * N_PHI samples of the light 
  // direction l, all having the same solid angle OMEGA_SAMPLE. This is used for
  // the diffuse component, and for the specular component when the roughness is
  // "large".
  const int N_Z = 3;
  const int N_PHI = 8;
  const float OMEGA_SAMPLE = 2.0 * PI / float(N_Z * N_PHI);
  const float OMEGA_TEXEL = 4.0 * PI / (6.0 * ENV_MAP_SIZE * ENV_MAP_SIZE);
  const float LOD = 0.5 * log2(OMEGA_SAMPLE / OMEGA_TEXEL);
  float n_dot_v = clamp(dot(surface.n, v), 0.0, 1.0);
  vec3 diffuse = vec3(0.0);
  vec3 specular = vec3(0.0);
  for (int i = 0; i < N_Z; ++i) {
    float cos_theta = (float(i) + 0.5) / float(N_Z);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);
    for (int j = 0; j < N_PHI; ++j) {
      float phi = float(j) * (2.0 * PI / float(N_PHI));
      vec3 l = GetVector(surface, cos_theta, sin_theta, phi);
      vec3 L = textureLod(env_map_texture, l, LOD).rgb;

      vec3 h = normalize(v + l);
      float n_dot_l = cos_theta;
      float n_dot_h = clamp(dot(surface.n, h), 0.0, 1.0);
      float v_dot_h = clamp(dot(v, h), 0.0, 1.0);
      vec3 F = Fresnel(surface.f0, v_dot_h);
      float V = MicroFacetVisibility(surface.alpha_sq, n_dot_l, n_dot_v);
      float D = MicroFacetDistribution(surface.alpha_sq, n_dot_h);

      // Note: the 1/pi factor is moved outside the loop, at the end.
      diffuse += surface.albedo * L * (vec3(1.0) - F) * n_dot_l;
      specular += L * F * (V * D * n_dot_l);
    }
  }
  diffuse *= OMEGA_SAMPLE / PI;
  specular *= OMEGA_SAMPLE;

  // Compute the specular component with importance sampling, when the roughness
  // is "small". References:
  // - https://blog.selfshadow.com/publications/s2013-shading-course/karis/
  //     s2013_pbs_epic_notes_v2.pdf
  // - https://placeholderart.wordpress.com/2015/07/28/implementation-notes-
  //     runtime-environment-map-filtering-for-image-based-lighting/
  // - https://github.com/KhronosGroup/glTF-IBL-Sampler/blob/master/lib/
  //     shaders/filter.frag
  const int SAMPLE_COUNT = 24;
  vec3 importance_specular = vec3(0.0);
  for (int i = 0; i < SAMPLE_COUNT; ++i) {
    float vdc = VAN_DER_CORPUT[i];
    float z_sq = (1.0 - vdc) / ((surface.alpha_sq - 1.0) * vdc + 1.0);
    float cos_theta = sqrt(z_sq);
    float sin_theta = sqrt(1.0 - z_sq);
    float phi = float(i) * (2.0 * PI / float(SAMPLE_COUNT));
    vec3 h = GetVector(surface, cos_theta, sin_theta, phi);

    vec3 l = reflect(-v, h);
    float n_dot_l = dot(surface.n, l);
    if (n_dot_l <= 0.0) continue;

    float n_dot_h = clamp(dot(surface.n, h), 0.0, 1.0);
    float v_dot_h = clamp(dot(v, h), 0.0, 1.0);
    vec3 F = Fresnel(surface.f0, v_dot_h);
    float V = MicroFacetVisibility(surface.alpha_sq, n_dot_l, n_dot_v);
    float D = MicroFacetDistribution(surface.alpha_sq, n_dot_h);

    float pdf = D * n_dot_h / (4.0 * v_dot_h);
    float omega_sample_inverse = pdf * float(SAMPLE_COUNT);
    float lod = -0.5 * log2(omega_sample_inverse * OMEGA_TEXEL);
    vec3 L = textureLod(env_map_texture, l, lod).rgb;

    importance_specular += L * F * (V * D * n_dot_l / pdf);
  }
  importance_specular *= (1.0 / float(SAMPLE_COUNT));

  return diffuse + (surface.alpha_sq < 0.0625 ? importance_specular : specular);
}

void main() {
  Surface surface = ComputeSurface();
  vec3 v = normalize(camera - position);
  frag_color = vec4(ImageBasedLighting(surface, v) * surface.occlusion, 1.0);
}
    </script>
    <script type="x-shader/x-vertex" id="vertex_shader">

uniform vec3 camera_size;

layout(location = 0) in vec4 vertex;

out vec3 view_dir;

void main() {
  view_dir = vec3(vertex.xy * camera_size.xy, -camera_size.z);
  gl_Position = vertex;
}
    </script>
    <script type="x-shader/x-fragment" id="fragment_shader">

// The camera position, in Schwarzschild coordinates (p^t, p^r, p^theta, p^phi).
uniform vec4 camera_position;
// The camera position, in (pseudo-)Cartesian coordinates.
uniform vec3 p;
// The camera 4-velocity, in Schwarzschild coordinates.
uniform vec4 k_s;
// The base vectors of the camera reference frame, in (pseudo-)Cartesian
// coordinates.
uniform vec3 e_tau, e_w, e_h, e_d;

uniform sampler2D ray_deflection_texture;
uniform sampler2D ray_inverse_radius_texture;

uniform samplerCube galaxy_cube_texture;
uniform samplerCube star_cube_texture;
uniform samplerCube star_cube_texture2;
uniform mat3 stars_orientation;
uniform float min_stars_lod;

uniform sampler2D black_body_texture;
uniform highp sampler3D doppler_texture;
uniform sampler2D noise_texture;
uniform vec3 disc_params;

in vec3 view_dir;

layout(location = 0) out vec4 frag_color;

// Simple ray-tracing function to compute the intersections of a ray with the
// scene, when the space-time geometry is assumed to be flat.
float TraceRayEuclidean(float p_r, float delta, float alpha, float u_ic,
                        float u_oc, out float u0, out float phi0, out float t0,
                        out float u1, out float phi1, out float t1) {
  float cos_delta = cos(delta);
  float sin_delta = sin(delta);
  float tan_alpha = tan(alpha);
  float det = 1.0 - p_r * p_r * sin_delta * sin_delta;
  float deflection = det > 0.0 && cos_delta < 0.0 ? -1.0 : 0.0;
  u0 = -1.0;
  u1 = -1.0;
  float t = p_r / (sin_delta / tan_alpha - cos_delta);
  float r = length(vec2(p_r + t * cos_delta, t * sin_delta));
  if (t >= 0.0 && r * u_oc <= 1.0 && r * u_ic >= 1.0 &&
      (deflection == 0.0 || t < p_r)) {
    u0 = 1.0 / r;
    phi0 = alpha;
    t0 = t;
  }
  return deflection;
}

float RayTrace(float u, float u_dot, float e_square, float delta, float alpha,
               float u_ic, float u_oc, out float u0, out float phi0,
               out float t0, out float alpha0, out float u1, out float phi1,
               out float t1, out float alpha1) {
#if (LENSING == 1)
  return TraceRay(ray_deflection_texture, ray_inverse_radius_texture, u,
                  u_dot, e_square, delta, alpha, u_ic, u_oc, u0, phi0, t0,
                  alpha0, u1, phi1, t1, alpha1);
#else
  alpha0 = 1.0;
  alpha1 = 1.0;
  return TraceRayEuclidean(1.0 / u, delta, alpha, u_ic, u_oc, u0, phi0, t0,
                           u1, phi1, t1);
#endif
}

vec3 GalaxyColor(vec3 dir) {
  dir = stars_orientation * dir;
#if (GRID == 1)
  return texture(galaxy_cube_texture, dir).rrr;
#else
  return texture(galaxy_cube_texture, dir).rgb * 6.78494e-5;
#endif
}

vec3 StarTextureColor(vec3 dir) {
#if (GRID == 1)
  return vec3(0.8);
#else
  return texture(star_cube_texture2, dir).rgb;
#endif
}

vec3 StarTextureColor(vec3 dir, float lod, out vec2 sub_position) {
#if (GRID == 1)
  sub_position = vec2(0.0);
  return vec3(100.0);
#else
  vec3 color = textureLod(star_cube_texture, dir, lod).rgb;
  ivec2 bits = floatBitsToInt(color.rb);
  sub_position = vec2((bits >> 8) % 257) / 257.0 - vec2(0.5);
  return color;
#endif
}

vec3 StarColor(vec3 dir, float lensing_amplification_factor) {
#if (STARS == 1)
  dir = stars_orientation * dir;
  return DefaultStarColor(dir, lensing_amplification_factor, min_stars_lod);
#else
  return vec3(0.0);
#endif
}

vec3 Doppler(vec3 rgb, float doppler_factor) {
#if (DOPPLER == 1)
  return DefaultDoppler(doppler_texture, rgb, doppler_factor);
#else
  return rgb;
#endif
}

vec4 GridDiscColor(vec2 p, float t, bool top_side, float doppler_factor,
                   float temperature, sampler2D black_body_texture) {
  float p_r = length(p);
  if (p_r <= INNER_DISC_R || p_r >= OUTER_DISC_R) {
    return vec4(0.0);
  }
  const float u_avg = 1.0 / 6.0;
  const float dphi_dt = u_avg * sqrt(0.5 * u_avg) / (2.0 * pi);
  float p_phi = atan(p.y, p.x) - t * dphi_dt;
  float value_phi = mod(p_phi / pi * 16.0, 1.0) < 0.2 ? 0.0 : 1.0;
  float value_r = mod(p_r / 2.0, 1.0) < 0.2 ? 0.0 : 1.0;
  vec3 color = BlackBodyColor(black_body_texture, temperature * doppler_factor);
  float pattern = 0.2 + 0.8 * value_phi * value_r;
  return vec4(color * (top_side ? pattern : 1.2 - pattern), 1.0);
}

float Noise(vec2 uv) {
  return 3.0 * (texture(noise_texture, uv).r - 0.5) + 1.0;
}

vec4 DiscColor(vec2 p, float t, bool top_side, float doppler_factor) {
  float density = disc_params.x;
  float opacity = disc_params.y;
  float temperature = disc_params.z;
#if (DOPPLER == 0)
  doppler_factor = 1.0;
#endif
#if (GRID == 1)
  vec4 color = GridDiscColor(p, t, top_side, doppler_factor, temperature,
                             black_body_texture);
#else
  vec4 color = DefaultDiscColor(p, t, top_side, doppler_factor, temperature,
                                black_body_texture);
#endif
  return vec4(density * color.rgb, opacity * color.a);
}

void main() {
  frag_color.rgb =
      SceneColor(camera_position, p, k_s, e_tau, e_w, e_h, e_d, view_dir);
  frag_color.a = 1.0;
}
    </script>
    <script type="x-shader/x-fragment" id="black_hole_shader">


// The types used in the main functions of our black hole shader. C++ equivalent
// of these types are used to compile these functions with a C++ compiler, both
// to reuse them in order to precompute the textures they need, and for testing
// them.

// Angles and dimensionless quantities.
#define Angle float
#define Real float

// An angle and a time (in the 1st and 2nd components, respectively).
#define TimedAngle vec2

// An inverse distance and a time (in the 1st and 2nd components, respectively).
#define TimedInverseDistance vec2

// A 2D texture with TimedAngle values.
#define RayDeflectionTexture sampler2D

// A 2D texture with TimedInverseDistance values.
#define RayInverseRadiusTexture sampler2D


const Real kMu = 4.0 / 27.0;

Real GetRayDeflectionTextureUFromEsquare(const Real e_square) {
  if (e_square < kMu) {
    return 0.5 - sqrt(-log(1.0 - e_square / kMu) * (1.0 / 50.0));
  } else {
    return 0.5 + sqrt(-log(1.0 - kMu / e_square) * (1.0 / 50.0));
  }
}


Real GetUapsisFromEsquare(const Real e_square) {
  Real x = (2.0 / kMu) * e_square - 1.0;
  return 1.0 / 3.0 + (2.0 / 3.0) * sin(asin(x) * (1.0 / 3.0));
}

Real GetRayDeflectionTextureVFromEsquareAndU(const Real e_square,
                                             const Real u) {
  if (e_square > kMu) {
    Real x = u < 2.0 / 3.0 ? -sqrt(2.0 / 3.0 - u) : sqrt(u - 2.0 / 3.0);
    return (sqrt(2.0 / 3.0) + x) / (sqrt(2.0 / 3.0) + sqrt(1.0 / 3.0));
  } else {
    return 1.0 - sqrt(max(1.0 - u / GetUapsisFromEsquare(e_square), 0.0));
  }
}


Real GetTextureCoordFromUnitRange(const Real x, const int texture_size) {
  return 0.5 / Real(texture_size) + x * (1.0 - 1.0 / Real(texture_size));
}

TimedAngle LookupRayDeflection(IN(RayDeflectionTexture) ray_deflection_texture,
                               const Real e_square, const Real u,
                               OUT(TimedAngle) deflection_apsis) {
  Real tex_u = GetTextureCoordFromUnitRange(
      GetRayDeflectionTextureUFromEsquare(e_square),
      RAY_DEFLECTION_TEXTURE_WIDTH);
  Real tex_v = GetTextureCoordFromUnitRange(
      GetRayDeflectionTextureVFromEsquareAndU(e_square, u),
      RAY_DEFLECTION_TEXTURE_HEIGHT);
  Real tex_v_apsis =
      GetTextureCoordFromUnitRange(1.0, RAY_DEFLECTION_TEXTURE_HEIGHT);
  deflection_apsis =
      TimedAngle(texture(ray_deflection_texture, vec2(tex_u, tex_v_apsis)));
  return TimedAngle(texture(ray_deflection_texture, vec2(tex_u, tex_v)));
}


Angle GetPhiUbFromEsquare(const Real e_square) {
  return (1.0 + e_square) / (1.0 / 3.0 + 2.0 * e_square * sqrt(e_square)) * rad;
}


Real GetRayInverseRadiusTextureUFromEsquare(const Real e_square) {
  return 1.0 / (1.0 + 6.0 * e_square);
}


TimedInverseDistance LookupRayInverseRadius(IN(RayInverseRadiusTexture)
                                                ray_inverse_radius_texture,
                                            const Real e_square,
                                            const Angle phi) {
  Real tex_u = GetTextureCoordFromUnitRange(
      GetRayInverseRadiusTextureUFromEsquare(e_square),
      RAY_INVERSE_RADIUS_TEXTURE_WIDTH);
  Real tex_v = GetTextureCoordFromUnitRange(phi / GetPhiUbFromEsquare(e_square),
                                            RAY_INVERSE_RADIUS_TEXTURE_HEIGHT);
  return TimedInverseDistance(
      texture(ray_inverse_radius_texture, vec2(tex_u, tex_v)));
}


// Anti-aliased pulse function. See
// https://renderman.pixar.com/resources/RenderMan_20/basicAntialiasing.html.
Real FilteredPulse(Real edge0, Real edge1, Real x, Real fw) {
  fw = max(fw, 1e-6);
  Real x0 = x - fw * 0.5;
  Real x1 = x0 + fw;
  return max(0.0, (min(x1, edge1) - max(x0, edge0)) / fw);
}

Angle TraceRay(IN(RayDeflectionTexture) ray_deflection_texture,
               IN(RayInverseRadiusTexture) ray_inverse_radius_texture,
               const Real u, const Real u_dot, const Real e_square,
               const Angle delta, const Angle alpha, const Real u_ic,
               const Real u_oc, OUT(Real) u0, OUT(Angle) phi0, OUT(Real) t0,
               OUT(Real) alpha0, OUT(Real) u1, OUT(Angle) phi1, OUT(Real) t1,
               OUT(Real) alpha1) {
  // Compute the ray deflection.
  u0 = -1.0;
  u1 = -1.0;
  if (e_square < kMu && u > 2.0 / 3.0) {
    return -1.0 * rad;
  }
  TimedAngle deflection_apsis;
  TimedAngle deflection = LookupRayDeflection(ray_deflection_texture, e_square,
                                              u, deflection_apsis);
  Angle ray_deflection = deflection.x;
  if (u_dot > 0.0) {
    ray_deflection =
        e_square < kMu ? 2.0 * deflection_apsis.x - ray_deflection : -1.0 * rad;
  }
  // Compute the accretion disc intersections.
  Real s = sign(u_dot);
  Angle phi = deflection.x + (s == 1.0 ? pi - delta : delta) + s * alpha;
  Angle phi_apsis = deflection_apsis.x + pi / 2.0;
  phi0 = mod(phi, pi);
  TimedInverseDistance ui0 =
      LookupRayInverseRadius(ray_inverse_radius_texture, e_square, phi0);
  if (phi0 < phi_apsis) {
    Real side = s * (ui0.x - u);
    if (side > 1e-3 || (side > -1e-3 && alpha < delta)) {
      u0 = ui0.x;
      phi0 = alpha + phi - phi0;
      t0 = s * (ui0.y - deflection.y);
    }
  }
  phi = 2.0 * phi_apsis - phi;
  phi1 = mod(phi, pi);
  TimedInverseDistance ui1 =
      LookupRayInverseRadius(ray_inverse_radius_texture, e_square, phi1);
  if (e_square < kMu && s == 1.0 && phi1 < phi_apsis) {
    u1 = ui1.x;
    phi1 = alpha + phi - phi1;
    t1 = 2.0 * deflection_apsis.y - ui1.y - deflection.y;
  }
  // Compute the anti-aliasing opacity values.
  Real fw0 = min(fwidth(ui0.x), fwidth(u0 == -1.0 ? u1 : u0));
  Real fw1 = min(fwidth(ui1.x), fwidth(u1 == -1.0 ? u0 : u1));
  alpha0 = FilteredPulse(u_oc, u_ic, u0, fw0);
  alpha1 = FilteredPulse(u_oc, u_ic, u1, fw1);
  if (s == 1.0 && abs(e_square - kMu) < min(fwidth(e_square), kMu)) {
    if (alpha0 < 0.99) u0 = 2.0 / (1.0 / u_ic + 1.0 / u_oc);
    if (alpha1 < 0.99) u1 = 2.0 / (1.0 / u_ic + 1.0 / u_oc);
  }
  return ray_deflection;
}

Angle TraceRay(IN(RayDeflectionTexture) ray_deflection_texture,
               IN(RayInverseRadiusTexture) ray_inverse_radius_texture,
               const Real p_r, const Angle delta, const Angle alpha,
               const Real u_ic, const Real u_oc, OUT(Real) u0,
               OUT(Angle) phi0, OUT(Real) t0, OUT(Real) alpha0, OUT(Real) u1,
               OUT(Angle) phi1, OUT(Real) t1, OUT(Real) alpha1) {
  Real u = 1.0 / p_r;
  Real u_dot = -u / tan(delta);
  Real e_square = u_dot * u_dot + u * u * (1.0 - u);
  return TraceRay(ray_deflection_texture, ray_inverse_radius_texture, u,
                  u_dot, e_square, delta, alpha, u_ic, u_oc, u0, phi0, t0,
                  alpha0, u1, phi1, t1, alpha1);
}


// Abstract functions, which must be implemented by the user:
// - ray tracing function (see the default implementation in functions.glsl).
Angle RayTrace(Real u, Real u_dot, Real e_square, Angle delta, Angle alpha,
               Real u_ic, Real u_oc, out Real u0, out Angle phi0, out Real t0,
               out Real alpha0, out Real u1, out Angle phi1, out Real t1,
               out Real alpha1);
// - Doppler function (see the default implementation below).
vec3 Doppler(vec3 rgb, float doppler_factor);
// - average color of the extended light sources (e.g. nebulae and galaxies) in
//   the footprint of the pixel in direction 'dir'.
vec3 GalaxyColor(vec3 dir);
// - average color of the punctual light sources (i.e. stars) in the footprint
//   of the pixel in direction 'dir'.
vec3 StarTextureColor(vec3 dir);
// - *sum* (in the footprint of the pixel in direction 'dir') of the colors of
//   the punctual light sources in the texel at 'lod' corresponding to 'dir',
//   and sub-texel position (in [-0.5,0.5]^2).
vec3 StarTextureColor(vec3 dir, float lod, out vec2 sub_position);
// - color of the stars in the footprint of the pixel in direction 'dir', times
//   the given gravitational lensing amplification factor.
vec3 StarColor(vec3 dir, float lensing_amplification_factor);
// - noise function used in the default accretion disc shading function 
//   'DefaultDiscColor()'.
float Noise(vec2 uv);
// - color and opacity of the accretion disc at 'p', and at time 't', for the
//   top or bottom side of the disc, and with the given Doppler factor.
vec4 DiscColor(vec2 p, float t, bool top_side, float doppler_factor);


// Returns the given color when shifted by the given Doppler factor. The 3D
// texture should contain this color at texture coord (r, 2*g, d) where r, g is
// the rg chromaticity and d = atan(log(doppler_factor) / 0.21) / 3 + 0.5.
vec3 DefaultDoppler(highp sampler3D doppler_texture, vec3 rgb,
                    float doppler_factor) {
  float sum = rgb.r + rgb.g + rgb.b;
  if (sum == 0.0) {
    return vec3(0.0);
  }
  vec3 tex_coord;
  tex_coord.x = rgb.r / sum;
  tex_coord.y = 2.0 * rgb.g / sum;
  tex_coord.z = (1.0 / 3.0) * atan((1.0 / 0.21) * log(doppler_factor)) + 0.5;
  return sum * texture(doppler_texture, tex_coord).rgb;
}


// Returns the light emitted by the stars in the pixel footprint around 'dir',
// times the given gravitational lensing amplification factor.
// This implementation uses the two 'StarTextureColor' functions above, and
// assumes that they are based on a cube map. The following constants must be
// provided by the user:
// - const float STARS_CUBE_MAP_SIZE = ...;
// - const float MAX_FOOTPRINT_SIZE = ...;
// - const float MAX_FOOTPRINT_LOD = ...;
// They define the size in pixels of the cube map, the maximum with and height
// of the footprint to consider around 'dir' (so the maximum number of texels
// used will be the square of this number), and the maximum LOD for which
// 'StarTextureColor(dir, lod, sub_position)' must be used (for larger LODs,
// 'StarTextureColor(dir)' is used instead).
vec3 DefaultStarColor(vec3 dir, float lensing_amplification_factor,
                      float min_lod) {
  // Compute the partial derivatives of dir (continuous across cube edges).
  vec3 dx_dir = dFdx(dir);
  vec3 dy_dir = dFdy(dir);

  // Swap the coordinates depending on the cube face, to always get the maximum
  // absolute value of the 'dir' components in the z coordinate.
  vec3 abs_dir = abs(dir);
  float max_abs_dir_comp = max(abs_dir.x, max(abs_dir.y, abs_dir.z));
  if (max_abs_dir_comp == abs_dir.x) {
    dir = dir.zyx;
    dx_dir = dx_dir.zyx;
    dy_dir = dy_dir.zyx;
  } else if (max_abs_dir_comp == abs_dir.y) {
    dir = dir.xzy;
    dx_dir = dx_dir.xzy;
    dy_dir = dy_dir.xzy;
  }

  // Compute the cube face texture coordinates uv and their derivatives dx_uv
  // and dy_uv (using an analytic formula instead of dFdx and dFdy, to avoid
  // discontinuities at cube edges - uv is not continuous here).
  float inv_dir_z = 1.0 / dir.z;
  vec2 uv = dir.xy * inv_dir_z;
  vec2 dx_uv = (dx_dir.xy - uv * dx_dir.z) * inv_dir_z;
  vec2 dy_uv = (dy_dir.xy - uv * dy_dir.z) * inv_dir_z;

  // Compute the LOD level to use to fetch the stars in the footprint of 'dir'.
  vec2 d_uv = max(abs(dx_uv + dy_uv), abs(dx_uv - dy_uv));
  vec2 fwidth = (0.5 * STARS_CUBE_MAP_SIZE / MAX_FOOTPRINT_SIZE) * d_uv;
  float lod = max(ceil(max(log2(fwidth.x), log2(fwidth.y))), min_lod);
  float lod_width = (0.5 * STARS_CUBE_MAP_SIZE) / pow(2.0, lod);
  if (lod > MAX_FOOTPRINT_LOD) {
    return StarTextureColor(dir);
  }

  // Fetch, filter and accumulate the colors of the stars in the texels in the
  // footprint of 'dir' at 'lod'.
  mat2 to_screen_pixel_coords = inverse(mat2(dx_uv, dy_uv));
  ivec2 ij0 = ivec2(floor((uv - d_uv) * lod_width));
  ivec2 ij1 = ivec2(floor((uv + d_uv) * lod_width));
  vec3 color_sum = vec3(0.0);
  for (int j = ij0.y; j <= ij1.y; ++j) {
    for (int i = ij0.x; i <= ij1.x; ++i) {
      vec2 texel_uv = (vec2(i, j) + vec2(0.5)) / lod_width;
      vec3 texel_dir = vec3(texel_uv * dir.z, dir.z);
      if (max_abs_dir_comp == abs_dir.x) {
        texel_dir = texel_dir.zyx;
      } else if (max_abs_dir_comp == abs_dir.y) {
        texel_dir = texel_dir.xzy;
      }
      vec2 delta_uv;
      vec3 star_color = StarTextureColor(texel_dir, lod, delta_uv);
      vec2 star_uv = uv - texel_uv + delta_uv / lod_width;
      vec2 star_pixel_coords = to_screen_pixel_coords * star_uv;
      vec2 overlap = max(vec2(1.0) - abs(star_pixel_coords), 0.0);
      color_sum += star_color * overlap.x * overlap.y;
    }
  }
  return color_sum * lensing_amplification_factor;
}


// Returns the light emitted by a black body at the given temperature. The 1D
// texture should contain this color at texture coord log(T / 100) / 6.
vec3 BlackBodyColor(sampler2D black_body_texture, float temperature) {
  float tex_u = (1.0 / 6.0) * log(temperature * (1.0 / 100.0));
  return texture(black_body_texture, vec2(tex_u, 0.5)).rgb;
}


// Returns the light emitted by the accretion disc at 'p', at time 'p_t', 
// shifted by the given Doppler factor. The 1D texture should contain the light
// emitted by a black body at temperature T at texture coord log(T / 100) / 6.
// The following constants must be provided by the user:
// - const float INNER_DISC_R = ...;
// - const float OUTER_DISC_R = ...;
// - const int NUM_DISC_PARTICLES = ...;
// - const vec4 DISC_PARTICLE_PARAMS[NUM_DISC_PARTICLES] = ...;
// They define the inner and outer radius of the disc, the number of particles
// used to compute its density, and the orbital parameters for each particle
// (inverse max and min radius, initial azimuth angle, precession 'ratio').
vec4 DefaultDiscColor(vec2 p, float p_t, bool top_side, float doppler_factor,
                      float disc_temperature, sampler2D black_body_texture) {
  float p_r = length(p);
  float p_phi = atan(p.y, p.x);

  float density = 0.0;
  for (int i = 0; i < NUM_DISC_PARTICLES; ++i) {
    vec4 params = DISC_PARTICLE_PARAMS[i];
    float u1 = params.x;
    float u2 = params.y;
    float phi0 = params.z;
    float dtheta_dphi = params.w;
    float u_avg = (u1 + u2) * 0.5;
    float dphi_dt = u_avg * sqrt(0.5 * u_avg);
    float phi = dphi_dt * p_t + phi0;
    float a = mod(p_phi - phi, 2.0 * pi);
    float s = sin(dtheta_dphi * (a + phi));
    float r = 1.0 / (u1 + (u2 - u1) * s * s);
    vec2 d = vec2(a - pi, r - p_r) * vec2(1.0 / pi, 0.5);
    float noise = Noise(d * vec2(p_r / OUTER_DISC_R, 1.0));
    density += smoothstep(1.0, 0.0, length(d)) * noise;
  }

  const float r_max = 49.0 / 12.0;
  const float temperature_profile_max =
      pow((1.0 - sqrt(3.0 / r_max)) / (r_max * r_max * r_max), 0.25);
  float temperature_profile =
      pow((1.0 - sqrt(3.0 / p_r)) / (p_r * p_r * p_r), 0.25);
  float temperature =
      disc_temperature * temperature_profile * (1.0 / temperature_profile_max);

  vec3 color = max(density, 0.0) *
      BlackBodyColor(black_body_texture, temperature * doppler_factor);
  float alpha = smoothstep(INNER_DISC_R, INNER_DISC_R * 1.2, p_r) *
      smoothstep(OUTER_DISC_R, OUTER_DISC_R / 1.2, p_r);
  return vec4(color * alpha, alpha);
}


// Finds the intersection of the given view ray with the scene, computes the
// emitted light at these intersection points, computes the corresponding
// received light, and composites and returns the final pixel color.
//
// Inputs:
// - camera_position: the camera position, in Schwarzschild coordinates
//     (p^t, p^r, p^theta, p^phi).
// - p: the camera position, in (pseudo-)Cartesian coordinates.
// - k_s: the camera 4-velocity, in Schwarzschild coordinates.
// - e_tau, e_w, e_h, e_d: the base vectors of the camera reference frame, in
//     (pseudo-)Cartesian coordinates.
// - view_dir: the view ray direction, in the camera reference frame.
vec3 SceneColor(vec4 camera_position, vec3 p, vec4 k_s, vec3 e_tau, vec3 e_w,
                vec3 e_h, vec3 e_d, vec3 view_dir) {
  vec3 q = normalize(view_dir);
  vec3 d = -e_tau + q.x * e_w + q.y * e_h + q.z * e_d;

  vec3 e_x_prime = normalize(p);
  vec3 e_z_prime = normalize(cross(e_x_prime, d));
  vec3 e_y_prime = normalize(cross(e_z_prime, e_x_prime));

  const vec3 e_z = vec3(0.0, 0.0, 1.0);
  vec3 t = normalize(cross(e_z, e_z_prime));
  if (dot(t, e_y_prime) < 0.0) {
    t = -t;
  }

  float alpha = acos(clamp(dot(e_x_prime, t), -1.0, 1.0));
  float delta = acos(clamp(dot(e_x_prime, normalize(d)), -1.0, 1.0));

  float u = 1.0 / camera_position[1];
  float u_dot = -u / tan(delta);
  float e_square = u_dot * u_dot + u * u * (1.0 - u);
  float e = -sqrt(e_square);

  const float U_IC = 1.0 / INNER_DISC_R;
  const float U_OC = 1.0 / OUTER_DISC_R;
  float u0, phi0, t0, alpha0, u1, phi1, t1, alpha1;
  float deflection = RayTrace(u, u_dot, e_square, delta, alpha, U_IC, U_OC,
                              u0, phi0, t0, alpha0, u1, phi1, t1, alpha1);

  vec4 l = vec4(e / (1.0 - u), -u_dot, 0.0, u * u);
  float g_k_l_receiver = k_s.x * l.x * (1.0 - u) - k_s.y * l.y / (1.0 - u) -
                         u * dot(e_tau, e_y_prime) * l.w / (u * u);

  float delta_prime = delta + max(deflection, 0.0);
  vec3 d_prime = cos(delta_prime) * e_x_prime + sin(delta_prime) * e_y_prime;

  vec3 color = vec3(0.0, 0.0, 0.0);
  if (deflection >= 0.0) {
    float g_k_l_source = e;
    float doppler_factor = g_k_l_receiver / g_k_l_source;

    // The solid angle (times 4pi) of the pixel.
    float omega = length(cross(dFdx(q), dFdy(q)));
    // The solid angle (times 4pi) of the deflected light beam.
    float omega_prime = length(cross(dFdx(d_prime), dFdy(d_prime)));

    float lensing_amplification_factor = omega / omega_prime;
    // Clamp the result (otherwise potentially infinite).
    lensing_amplification_factor = min(lensing_amplification_factor, 1e6);

    // The galaxy texture contains the radiant intensity of stars, per unit area
    // on the celestial sphere, i.e. radiance values (using omega0 as area unit,
    // with omega0 = 4pi * the solid angle of the center texel of a cube face).
    // The stars texture contains radiant intensities. To convert the total
    // intensity inside a pixel to a radiance, this intensity must be divided by
    // the pixel area on the celestial sphere. Expressed in the units used for
    // the galaxy texture, this area is omega / omega0 (where, since the galaxy
    // texture is a 2048x2048 cubemap, omega0 is 1 / 1024^2).
    float pixel_area = max(omega * (1024.0 * 1024.0), 1.0);

    color += GalaxyColor(d_prime);
    color += StarColor(d_prime, lensing_amplification_factor / pixel_area);
    color = Doppler(color, doppler_factor);
  }
  if (u1 >= 0.0 && alpha1 > 0.0) {
    float g_k_l_source = e * sqrt(2.0 / (2.0 - 3.0 * u1)) -
                         u1 * sqrt(u1 / (2.0 - 3.0 * u1)) * dot(e_z, e_z_prime);
    float doppler_factor = g_k_l_receiver / g_k_l_source;
    bool top_side =
        (mod(abs(phi1 - alpha), 2.0 * pi) < 1e-3) == (e_x_prime.z > 0.0);

    vec3 i1 = (e_x_prime * cos(phi1) + e_y_prime * sin(phi1)) / u1;
    vec4 disc_color =
        DiscColor(i1.xy, camera_position[0] - t1, top_side, doppler_factor);
    color = color * (1.0 - disc_color.a) + alpha1 * disc_color.rgb;
  }
  if (u0 >= 0.0 && alpha0 > 0.0) {
    float g_k_l_source = e * sqrt(2.0 / (2.0 - 3.0 * u0)) -
                         u0 * sqrt(u0 / (2.0 - 3.0 * u0)) * dot(e_z, e_z_prime);
    float doppler_factor = g_k_l_receiver / g_k_l_source;
    bool top_side =
        (mod(abs(phi0 - alpha), 2.0 * pi) < 1e-3) == (e_x_prime.z > 0.0);

    vec3 i0 = (e_x_prime * cos(phi0) + e_y_prime * sin(phi0)) / u0;
    vec4 disc_color =
        DiscColor(i0.xy, camera_position[0] - t0, top_side, doppler_factor);
    color = color * (1.0 - disc_color.a) + alpha0 * disc_color.rgb;
  }
  return color;
}
    </script>
    <div class="cv-container">
      <canvas id="camera_view" width="400" height="300"></canvas>
      <div id="cv_error_panel" class="cv-error-panel cv-hidden">
      </div>
      <div id="cv_loading_panel" class="cv-loading-panel">
        <span>Loading stars data...</span>
        <div class="cv-loading-bar">
          <div id="cv_loading_bar" class="cv-loading-bar-value"></div>
        </div>
        <span>Press <em>space</em> to show / hide the User Interface</span>
      </div>
      <div class="cv-copyright">@2020 Eric Bruneton. 
        <a href="https://github.com/ebruneton/black_hole_shader"
           target="_blank">
          GitHub project
        </a>. Star data from 
        <a href="https://www.cosmos.esa.int/web/gaia/dr2" 
           target="_blank">
          Gaia DR2
        </a> and 
        <a href="https://www.cosmos.esa.int/web/hipparcos/tycho-2" 
           target="_blank">
          Tycho 2
        </a>
      </div>
    </div>
    <div id="orbit_panel" class="op-panel op-hidden">
      <canvas id="canvas" width="400" height="400"></canvas>
      <div id="op_dot" class="op-dot"></div>
      <div id="op_frustum0" class="op-frustum"></div>
      <div id="op_frustum1" class="op-frustum"></div>
      <div id="op_frustum2" class="op-frustum"></div>
      <div id="op_frustum3" class="op-frustum"></div>
      <div id="op_frustum4" class="op-frustum"></div>
      <div id="op_frustum5" class="op-frustum"></div>
      <div id="op_frustum6" class="op-frustum"></div>
      <div id="op_frustum7" class="op-frustum"></div>
      <div id="op_frustum8" class="op-frustum"></div>
      <div class="op-info">
         <div title="Radius of the black hole's event horizon, in kilometers">
           Black hole radius:
           <span id="op_black_hole_radius"></span>
         </div>
         <div title="Distance of the observer from the black hole center, in kilometers
(i.e. the Schwarzschild 'r' coordinate)">
           Distance: 
           <span id="op_radius"></span>
         </div>
         <div title="Speed of the observer, in kilometers per second
(with respect to a static observer at the current location)">
           Speed: 
           <span id="op_speed"></span>
         </div>
         <div title="The g-force experienced by the observer">
           G-force: 
           <span id="op_gforce"></span>
         </div>
         <div title="Proper time of the observer, in seconds">
           Local time:
           <span id="op_local_time"></span>
         </div>
         <div title="Time on Earth, in seconds">
           Earth time: 
           <span id="op_global_time"></span>
         </div>
         <div title="Time dilation factor
(1 second for the observer = <Time dilation> seconds on Earth)">
           Time dilation:
           <span id="op_time_dilation"></span>
         </div>
      </div>
    </div>
    <form id="settings_panel" class="sp-panel sp-hidden">
      <details open="true" class="sp-settings-container">
        <summary>Camera</summary>

        <div class="sp-setting" 
             title="Camera exposure, in stops
(one stop = doubling or halving the amount of light you let in)

Shortcut keys: '+' / '-' to increase / decrease exposure.">
          <label>Exposure</label>
          <span class="sp-slider-container">
            <button type="button">-</button>
            <input type="range" id="sp_exposure">
            <button type="button">+</button>
          </span>
          <span id="sp_exposure_value" class="sp-value"></span>
        </div>

        <div class="sp-setting"
             title="Bloom intensity
(amount of scattering and diffraction in the camera)">
          <label>Bloom</label>
          <span class="sp-slider-container">
            <button type="button">-</button>
            <input type="range" id="sp_bloom">
            <button type="button">+</button>
          </span>
          <span id="sp_bloom_value" class="sp-value"></span>
        </div>

        <div class="sp-setting" 
             title="Enables a higher image resolution (decreases performance)"
             id="sp_high_definition_div">
          <label for="sp_high_definition">High Definition</label>
          <input type="checkbox" id="sp_high_definition">
        </div>

        <div class="sp-setting" title="Enables a higher contrast">
          <label for="sp_high_contrast">High contrast</label>
          <input type="checkbox" id="sp_high_contrast">
        </div>

        <div class="sp-setting" title="Camera view">
          <label>View</label>
          <span class="sp-target-container" id="sp_target_container">
            <button type="button" id="sp_target0"
                    title="Default view
Shortcut key: 'd'">○</button>
            <button type="button" id="sp_target1"
                    title="Black hole view
Shortcut key: 'b'">●</button>
            <button type="button" id="sp_target2"
                    title="Left view
Shortcut key: 'l'">◂</button>
            <button type="button" id="sp_target3"
                    title="Front view
Shortcut key: 'f'">▴</button>
            <button type="button" id="sp_target4"
                    title="Right view
Shortcut key: 'r'">▸</button>
          </span>
        </div>

        <h3>Orbit</h3>

        <div class="sp-settings-container">
          <div class="sp-setting" 
               title="Initial distance of the observer from the black hole center
(i.e. the Schwarzschild 'r' coordinate, divided by the black hole radius)

Shortcut: use the mouse wheel to increase / decrease the initial distance">
            <label>Initial distance</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_start_radius">
              <button type="button">+</button>
            </span>
            <span id="sp_start_radius_value" class="sp-value"></span>
          </div>

          <div class="sp-setting"
               title="Initial direction of the observer's trajectory
(in degrees)">
            <label>Initial direction</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_start_direction">
              <button type="button">+</button>
            </span>
            <span id="sp_start_direction_value" class="sp-value"></span>
          </div>

          <div class="sp-setting" 
               title="Initial speed of the observer
(with respect to a static observer, as a fraction of the speed of light)">
            <label>Initial speed</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_start_speed">
              <button type="button">+</button>
            </span>
            <span id="sp_start_speed_value" class="sp-value"></span>
          </div>

          <div class="sp-setting" 
               title="Inclination of the observer's orbit plane
(with respect to the accretion disc, in degrees)">
            <label>Inclination</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_orbit_inclination">
              <button type="button">+</button>
            </span>
            <span id="sp_orbit_inclination_value" class="sp-value"></span>
          </div>

          <div class="sp-setting">
            <label>Motion</label>
            <span class="sp-play-container">
              <button id="sp_play" type="button" class="sp-play"
                      title="Play

Shortcut key: 'p'">⏵</button>
              <button id="sp_pause" type="button" class="sp-pause" 
                      title="Pause

Shortcut key: 'p'">⏸</button>
              <button id="sp_stop" type="button" class="sp-stop" 
                      title="Stop">⏹</button>
            </span>
          </div>
        </div>
      </details>

      <details open="true" class="sp-settings-container">
        <summary>Physics</summary>

        <div class="sp-setting" 
             title="Enables the bending of light by the gravitational field">
          <label for="sp_lensing">Lensing</label>
          <input type="checkbox" id="sp_lensing">
        </div>

        <div class="sp-setting"
             title="Enables the relativistic and gravitational Doppler and beaming effects">
          <label for="sp_doppler">Doppler</label>
          <input type="checkbox" id="sp_doppler">
        </div>
      </details>

      <details open="true" class="sp-settings-container">
        <summary>Scene</summary>

        <div class="sp-setting" 
             title="Enables non-realistic grid patterns
(to better illustrate the physical phenomena)">
          <label for="sp_grid">Grid</label>
          <input type="checkbox" id="sp_grid">
        </div>

        <div class="sp-setting" 
             title="Black hole mass (in Solar mass)">
          <label>Black hole mass</label>
          <span class="sp-slider-container">
            <button type="button">-</button>
            <input type="range" id="sp_black_hole_mass">
            <button type="button">+</button>
          </span>
          <span id="sp_black_hole_mass_value" class="sp-value"></span>
        </div>

        <h3>Disc</h3>

        <div class="sp-settings-container">
          <div class="sp-setting"
               title="Density of the accretion disc (in unspecified units)">
            <label>Density</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_disc_density">
              <button type="button">+</button>
            </span>
            <span id="sp_disc_density_value" class="sp-value"></span>
          </div>

          <div class="sp-setting"
               title="Opacity of the accretion disc (in percentage)">
            <label>Opacity</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_disc_opacity">
              <button type="button">+</button>
            </span>
            <span id="sp_disc_opacity_value" class="sp-value"></span>
          </div>

          <div class="sp-setting" 
               title="Maximum temperature of the accretion disc (in Kelvins)">
            <label>Temperature</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_disc_temperature">
              <button type="button">+</button>
            </span>
            <span id="sp_disc_temperature_value" class="sp-value"></span>
          </div>
        </div>

        <h3>Rocket</h3>

        <div class="sp-settings-container">
          <div class="sp-setting" 
               title="Average distance from the rocket (in meters)">
            <label>Distance</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_rocket_distance">
              <button type="button">+</button>
            </span>
            <span id="sp_rocket_distance_value" class="sp-value"></span>
          </div>

          <div class="sp-setting" 
               title="Shows the observer's rocket">
            <label for="sp_rocket">Enabled</label>
            <input type="checkbox" id="sp_rocket">
          </div>
        </div>

        <h3>Stars</h3>

        <div class="sp-settings-container">
          <div class="sp-setting" 
               title="Orientation of the star field (yaw)

Shortcut: CTRL + mouse drag">
            <label>Yaw</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_stars_yaw">
              <button type="button">+</button>
            </span>
            <span id="sp_stars_yaw_value" class="sp-value"></span>
          </div>

          <div class="sp-setting"
               title="Orientation of the star field (pitch)

Shortcut: CTRL + mouse drag">
            <label>Pitch</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_stars_pitch">
              <button type="button">+</button>
            </span>
            <span id="sp_stars_pitch_value" class="sp-value"></span>
          </div>

          <div class="sp-setting" 
               title="Orientation of the star field (roll)

Shortcut: CTRL + mouse drag">
            <label>Roll</label>
            <span class="sp-slider-container">
              <button type="button">-</button>
              <input type="range" id="sp_stars_roll">
              <button type="button">+</button>
            </span>
            <span id="sp_stars_roll_value" class="sp-value"></span>
          </div>

          <div class="sp-setting sp-last" 
               title="Enables stars">
            <label for="sp_stars">Enabled</label>
            <input type="checkbox" id="sp_stars" checked>
          </div>

        </div>
      </details>
    </form>
  </body>
</html>
